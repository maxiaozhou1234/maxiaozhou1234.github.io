<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xiaozhou Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://maxiaozhou1234.github.io/"/>
  <updated>2021-03-14T11:24:44.852Z</updated>
  <id>https://maxiaozhou1234.github.io/</id>
  
  <author>
    <name>ma xiaozhou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【java】Pipe</title>
    <link href="https://maxiaozhou1234.github.io/java/java-pipe/"/>
    <id>https://maxiaozhou1234.github.io/java/java-pipe/</id>
    <published>2021-03-14T10:32:17.000Z</published>
    <updated>2021-03-14T11:24:44.852Z</updated>
    
    <content type="html"><![CDATA[<p>java Pipe 管道流</p><h3 id="1-Pipe-管道"><a href="#1-Pipe-管道" class="headerlink" title="1. Pipe 管道"></a>1. Pipe 管道</h3><p>对于数据流的处理，一般情况下我们在同一个线程中进行。如果遇到异步处理场景，一边进行数据写入，另一线程进行数据读取，那么 Pipe 管道可以很好解决这个问题。</p><p>先看 Pipe 的原理图示：</p><p><img src="http://ifeve.com/wp-content/uploads/2013/06/pipe.bmp" alt=""></p><p>在同一管道中，Sink 作为头进行数据写入，而 Source 端进行数据读取，实现了数据的流通，就像是水管，一头流入，一头流出。因为 Pipe 具备了 sink 和 source，所以在不同线程中，可以通过同一个 pipe 实现一端数据写入，一端读取，从而实现了不同线程间的数据流通信。</p><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h3><p>先打开一个 Pipe，为了模拟不同线程通信，先启动线程，读取本地文件，再写入管道，另一个线程读取，并将接收的数据打印出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;开启一个通道</span><br><span class="line">Pipe pipe &#x3D; Pipe.open();</span><br><span class="line">&#x2F;&#x2F;线程：模拟数据写入</span><br><span class="line">CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    Pipe.SinkChannel sinkChannel &#x3D; pipe.sink();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);</span><br><span class="line">        FileChannel fileChannel &#x3D; new FileInputStream(&quot;.&#x2F;res&#x2F;normal.txt&quot;).getChannel();</span><br><span class="line">        &#x2F;&#x2F;读取文件中数据，写入管道</span><br><span class="line">        while (fileChannel.read(buffer) !&#x3D; -1) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            sinkChannel.write(buffer);</span><br><span class="line">            buffer.clear();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(200);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;exit system&quot;);</span><br><span class="line">        fileChannel.close();</span><br><span class="line">        sinkChannel.close();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);</span><br><span class="line">&#x2F;&#x2F;拿到 source 端，读取数据</span><br><span class="line">Pipe.SourceChannel source &#x3D; pipe.source();</span><br><span class="line">while (source.read(buffer) !&#x3D; -1) &#123;</span><br><span class="line">    buffer.flip();</span><br><span class="line">    String data &#x3D; new String(buffer.array(), StandardCharsets.UTF_8);</span><br><span class="line">    System.out.println(data);</span><br><span class="line">    buffer.clear();</span><br><span class="line">    if (&quot;stop&quot;.equals(data)) &#123;</span><br><span class="line">        System.out.println(&quot;load stop,exit!&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">source.close();</span><br></pre></td></tr></table></figure><p>在数据流处理角度上看，和通常使用的 InputStream OutputStream，并没有区别。</p><h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h3><p>Pipe 在开发中使用较少，写这篇的主要原因在于一天看到一篇关于 zero-copy 的文章，里面除了利用 NIO Channel 进行举例，还使用了 Pipe，让我误会 Pipe 能够进一步加速文件数据的复制操作，在了解之后发现那个博主纯粹是为了使用而使用。<br>Pipe 就是一个单纯连接输入端和输出端的工具，仅此而已。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;java Pipe 管道流&lt;/p&gt;
&lt;h3 id=&quot;1-Pipe-管道&quot;&gt;&lt;a href=&quot;#1-Pipe-管道&quot; class=&quot;headerlink&quot; title=&quot;1. Pipe 管道&quot;&gt;&lt;/a&gt;1. Pipe 管道&lt;/h3&gt;&lt;p&gt;对于数据流的处理，一般情况下我们在同一
      
    
    </summary>
    
    
      <category term="java" scheme="https://maxiaozhou1234.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://maxiaozhou1234.github.io/tags/java/"/>
    
      <category term="nio" scheme="https://maxiaozhou1234.github.io/tags/nio/"/>
    
  </entry>
  
  <entry>
    <title>【java】Mapper 自定义注解器</title>
    <link href="https://maxiaozhou1234.github.io/android/java-annotation/"/>
    <id>https://maxiaozhou1234.github.io/android/java-annotation/</id>
    <published>2020-07-12T06:21:09.000Z</published>
    <updated>2020-07-12T09:54:37.104Z</updated>
    
    <content type="html"><![CDATA[<p>java 自定义注解器，提交私仓 maven</p><h3 id="1-java-自定义注解器"><a href="#1-java-自定义注解器" class="headerlink" title="1. java 自定义注解器"></a>1. java 自定义注解器</h3><h4 id="1-1-注解器作用"><a href="#1-1-注解器作用" class="headerlink" title="1.1 注解器作用"></a>1.1 注解器作用</h4><p>通过元注解对类、变量等进行标记，在代码编译期通过解析器 <code>AbstractProcessor</code> 进行解析，快速实现模板代码的构建等作用</p><h4 id="1-2-自定义注解"><a href="#1-2-自定义注解" class="headerlink" title="1.2 自定义注解"></a>1.2 自定义注解</h4><p>通过 <code>@interface</code> 实现注解，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.CLASS)</span><br><span class="line">public @interface MapType &#123;</span><br><span class="line">String name() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-实现一个解析器-Processor"><a href="#1-3-实现一个解析器-Processor" class="headerlink" title="1.3 实现一个解析器 Processor"></a>1.3 实现一个解析器 <code>Processor</code></h4><ol><li>必须继承 <code>AbstractProcessor</code>，通过方法 <code>public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</code> 对定义的注解类型进行解析。</li><li>需要重写 <code>getSupportedAnnotationTypes()</code> 声明对哪些些注解生效</li><li>在 <code>init(ProcessingEnvironment processingEnv)</code> 中获取工具类，如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public synchronized void init(ProcessingEnvironment processingEnv) &#123;</span><br><span class="line">        super.init(processingEnv);</span><br><span class="line">Types typeUtils &#x3D; processingEnv.getTypeUtils();</span><br><span class="line">Elements elementUtils &#x3D; processingEnv.getElementUtils();</span><br><span class="line">Filter filer &#x3D; processingEnv.getFiler();</span><br><span class="line">Messager messager &#x3D; processingEnv.getMessager();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="1-4-解析注解，构建类"><a href="#1-4-解析注解，构建类" class="headerlink" title="1.4 解析注解，构建类"></a>1.4 解析注解，构建类</h4><p>从自定义解析器可以获取并处理自定义注解类型，动态构建类可以通过 <code>JavaWriter</code> 或者 <code>JavaPoet</code>。<br><code>JavaPoet</code> 是对 <code>JavaWriter</code> 的进一步封装。<br>如何使用参考官网介绍：<br><a href="https://github.com/square/javapoet" target="_blank" rel="noopener">JavaPoet github 链接</a></p><h3 id="2-实现注解库"><a href="#2-实现注解库" class="headerlink" title="2. 实现注解库"></a>2. 实现注解库</h3><p>新建 java library，建议使用 idea 的 maven/gradle 工程</p><h4 id="2-1-mapper-annotation-注解库"><a href="#2-1-mapper-annotation-注解库" class="headerlink" title="2.1 mapper-annotation 注解库"></a>2.1 mapper-annotation 注解库</h4><p>新建 java library，命名为 mapper-annotation，用于存放注解。<br>也可以把注解、解析器等放在同一个库中，但一般解析器所依赖的库只需要在编译期使用，不需要打包进主工程，所以会选择库拆分。</p><h4 id="2-2-mapper-compiler-解析库"><a href="#2-2-mapper-compiler-解析库" class="headerlink" title="2.2 mapper-compiler 解析库"></a>2.2 mapper-compiler 解析库</h4><p>同样新建 java library，再添加 <code>JavaPoet</code> 依赖，在 module 的 build.gradle 中添加 <code>implementation group: &#39;com.squareup&#39;, name: &#39;javapoet&#39;, version: &#39;1.8.0&#39;</code><br>在项目调试阶段，增加注解库依赖 <code>implementation project(&quot;:mapper-annotation&quot;)</code>，在调试完成后，可以将直接依赖替换为线上依赖，如 <code>implementation &#39;com.lib:mapper-annotation:1.0.0&#39;</code></p><h4 id="2-3-mapper-aar-库"><a href="#2-3-mapper-aar-库" class="headerlink" title="2.3 mapper aar 库"></a>2.3 mapper aar 库</h4><p>这个库主要是存放对外访问的接口。给 android 项目使用，如果没有这类需求可以不加，或者也可以放入 annotation 库中，不是必要创建的库。<br>新建 android library，同样需要添加对 annotation 依赖，在上线后替换为线上版本，如上。</p><h3 id="3-自定义-mapper-注解库需求及实现"><a href="#3-自定义-mapper-注解库需求及实现" class="headerlink" title="3. 自定义 mapper 注解库需求及实现"></a>3. 自定义 mapper 注解库需求及实现</h3><h4 id="3-1-构建需求"><a href="#3-1-构建需求" class="headerlink" title="3.1 构建需求"></a>3.1 构建需求</h4><p>在业务项目中使用了大量的组件，在使用中需要根据用户的组件类型去匹配，呈现该组件。在原先开发中，流程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void showComponent(Item item)&#123;</span><br><span class="line">String type &#x3D; item.getType();</span><br><span class="line">if(&quot;A&quot;.equals(type)&#123;</span><br><span class="line">Component cc &#x3D; new A(item);</span><br><span class="line">cc.show();</span><br><span class="line">&#125;else if(&quot;B&quot;.equals(type)&#123;</span><br><span class="line">Component cc &#x3D; new B(item);</span><br><span class="line">cc.show();</span><br><span class="line">&#125;else if(&quot;C&quot;.equals(type)&#123;</span><br><span class="line">Component cc &#x3D; new C(item);</span><br><span class="line">cc.show();</span><br><span class="line">&#125;else &#123;</span><br><span class="line">&#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在少量组件的情况下，使用 if-else 结构清晰，但随着项目扩展，这段判断特别长，因此有了第一次改造，修改后如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private static HashMap&lt;Strng,Class&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">static&#123;</span><br><span class="line">map.put(&quot;A&quot;,A.class);</span><br><span class="line">map.put(&quot;B&quot;,B.class);</span><br><span class="line">map.put(&quot;C&quot;,C.class);</span><br><span class="line">&#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void showComponent(Item item)&#123;</span><br><span class="line">Class clz &#x3D; map.get(item.getType());</span><br><span class="line">if(clz!&#x3D;null)&#123;</span><br><span class="line">try&#123;</span><br><span class="line">Component cc &#x3D; clz.getConstructor(Item.class).newInstance(item);</span><br><span class="line">cc.show();</span><br><span class="line">&#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 HashMap 查找，让 if-else 瞬间去无踪，但是前提还是需要先构建 Map，为了一步到位，决定使用注解方式实现，彻底释放双手。</p><h4 id="3-2-实现"><a href="#3-2-实现" class="headerlink" title="3.2 实现"></a>3.2 实现</h4><ol><li>定义注解<br>因为可能存在组的概念，所以需要定义一个组名，再定义key用于标记该类，同时可能存在多个不同类型使用同一个类情况，提供一个组存放所有的类型，那么该注解完整如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.CLASS)</span><br><span class="line">public @interface MapType &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 存放组</span><br><span class="line">     *&#x2F;</span><br><span class="line">    String group() default Constant.defaultGroup;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 用于标记的 key</span><br><span class="line">     *&#x2F;</span><br><span class="line">    String name() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 多个 key 共用一个类，可以使用 array 标记</span><br><span class="line">     *&#x2F;</span><br><span class="line">    String[] array() default &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>定义注解用于类，并保持到源码，defalut 是默认值，由于提供了一组使用，所以允许 name 或者 array 其中一个为空，但在构建需要对 name 和 array 进行都为空判断，不允许都为空，而 group 提供一个默认组存放。</li><li>解析注解<br>新建解析器 <code>MapProcessor</code>，继承 <code>AbstractProcessor</code></li></ol><p><strong>注意：需要在 main 中创建目录 C:\code\AnnotationApp\mapper-compiler\src\main\resources\META-INF\services 并添加注解器声明文件javax.annotation.processing.Processor，内容为自定义的注解器完整类名，如下图。当然可以通过 google 提供的 AutoService 自动生成，依赖为<code>compile group: &#39;com.google.auto.service&#39;, name: &#39;auto-service&#39;, version: &#39;1.0-rc7&#39;</code></strong><br><img src="https://i.loli.net/2020/07/12/SWzNrit2sKJGxYl.png" alt="注解器配置"><br>在 process 进行解析，并通过 <code>JavaPoet</code> 去生成上面改造后 map 的静态代码。部分代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123;</span><br><span class="line">    if (!annotations.isEmpty()) &#123;</span><br><span class="line">        HashMap&lt;String, HashMap&lt;String, ClassName&gt;&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; process start &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        for (Element annotatedElement : roundEnv.getElementsAnnotatedWith(MapType.class)) &#123;</span><br><span class="line">            if (annotatedElement.getKind() &#x3D;&#x3D; ElementKind.CLASS) &#123;&#x2F;&#x2F;只对类的注解进行处理</span><br><span class="line">                MapType annotation &#x3D; annotatedElement.getAnnotation(MapType.class);</span><br><span class="line">                String group &#x3D; annotation.group();</span><br><span class="line">                String name &#x3D; annotation.name();</span><br><span class="line">                String[] array &#x3D; annotation.array();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;空判断，不允许都为空，key 为空字符容易出现覆盖，同时需注意同组同key有覆盖风险！！</span><br><span class="line">                if (name.length() &#x3D;&#x3D; 0 &amp;&amp; array.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    &#x2F;&#x2F;写出异常日志</span><br><span class="line">                    log(Diagnostic.Kind.ERROR, &quot;type name and array are Empty.&quot;);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                TypeElement typeElement &#x3D; (TypeElement) annotatedElement;</span><br><span class="line">                ClassName className &#x3D; ClassName.get(typeElement);&#x2F;&#x2F;获取被注解的类</span><br><span class="line">                log(&quot;className &gt;&gt; &quot; + className);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;保存入临时 map</span><br><span class="line">                HashMap&lt;String, ClassName&gt; items &#x3D; map.get(group);</span><br><span class="line">                if (items &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    items &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">                    map.put(group, items);</span><br><span class="line">                &#125;</span><br><span class="line">                if (name.length() &gt; 0) &#123;</span><br><span class="line">                    items.put(name, className);</span><br><span class="line">                &#125;</span><br><span class="line">                if (array.length &gt; 0) &#123;</span><br><span class="line">                    for (String s : array) &#123;</span><br><span class="line">                        items.put(s, className);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;构建静态class文件</span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">            ClassName hashMapName &#x3D; ClassName.get(HashMap.class);</span><br><span class="line">            ClassName stringName &#x3D; ClassName.get(String.class);</span><br><span class="line">            ClassName className &#x3D; ClassName.get(Class.class);</span><br><span class="line"></span><br><span class="line">            ParameterizedTypeName itemMap &#x3D; ParameterizedTypeName.get(hashMapName, stringName, className);</span><br><span class="line">            ParameterizedTypeName hashMap &#x3D; ParameterizedTypeName.get(hashMapName, stringName, itemMap);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建 HashMap&lt;String,HashMap&lt;String,Class&gt;&gt; map;</span><br><span class="line">            FieldSpec fieldMap &#x3D; FieldSpec.builder(hashMap, &quot;map&quot;, Modifier.PUBLIC, Modifier.STATIC)</span><br><span class="line">                    .initializer(&quot;new $T()&quot;, hashMap)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            StringBuilder body &#x3D; new StringBuilder();</span><br><span class="line">            CodeBlock.Builder codeBuilder &#x3D; CodeBlock.builder()</span><br><span class="line">                    .addStatement(&quot;$T item&quot;, itemMap);</span><br><span class="line"></span><br><span class="line">            for (Map.Entry&lt;String, HashMap&lt;String, ClassName&gt;&gt; item : map.entrySet()) &#123;</span><br><span class="line">                body.setLength(0);</span><br><span class="line"></span><br><span class="line">                String group &#x3D; item.getKey();</span><br><span class="line">                System.out.println(&quot; &gt;&gt; group : &quot; + group + &quot; &lt;&lt; &quot;);</span><br><span class="line">                codeBuilder.addStatement(&quot;item &#x3D; new $T()&quot;, itemMap);</span><br><span class="line">                for (Map.Entry&lt;String, ClassName&gt; m : item.getValue().entrySet()) &#123;</span><br><span class="line">                    System.out.println(&quot;[ &quot; + m.getKey() + &quot;: &quot; + m.getValue());</span><br><span class="line">                    body.append(&quot;item.put(\&quot;&quot;).append(m.getKey()).append(&quot;\&quot;,&quot;).append(m.getValue()).append(&quot;.class);\n&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                codeBuilder.add(body.toString())</span><br><span class="line">                        .add(&quot;map.put(\&quot;&quot;).add(group).addStatement(&quot;\&quot;, item)&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;构建静态class为 当前package.TypeMap$Data</span><br><span class="line">            TypeSpec.Builder classBuilder &#x3D; TypeSpec.classBuilder(&quot;TypeMap$Data&quot;)</span><br><span class="line">                    .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">                    .addField(fieldMap)</span><br><span class="line">                    .addStaticBlock(codeBuilder.build());</span><br><span class="line"></span><br><span class="line">            JavaFile javaFile &#x3D; JavaFile.builder(this.getClass().getPackage().getName(), classBuilder.build()).build();</span><br><span class="line">            javaFile.writeTo(filer);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            if (e instanceof FilerException) &#123;</span><br><span class="line">                &#x2F;&#x2F;</span><br><span class="line">            &#125; else</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; end &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，在添加这个注解库后，通过 build 能够动态生成 TypeMap$Data。在android 工程中，生成的目录为 <code>\build\generated\ap_generated_sources\debug\out\com\lib\mapper</code>，内容如下：<br><img src="https://i.loli.net/2020/07/12/5USxhuIpPzKBNeg.png" alt="构建成功截图"><br>3. 对外暴露接口<br>在 mapper 中，定义静态类，用于链接上面生成的类。<br>由于 TypeMap$Data 是编译期才生成，如果在没有build之前，直接引用 <code>TypeMap$Data</code> 的成员变量，会报错，有可能导致项目无法构建，所以通过反射方式获取到成员变量，相关代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Mapper &#123;</span><br><span class="line"></span><br><span class="line">    private final static HashMap&lt;String, HashMap&lt;String, Class&gt;&gt; collection;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        HashMap&lt;String, HashMap&lt;String, Class&gt;&gt; temp &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class typeMap &#x3D; Class.forName(&quot;com.lib.mapper.TypeMap$Data&quot;);</span><br><span class="line">            Object instance &#x3D; typeMap.newInstance();</span><br><span class="line">            Field map &#x3D; typeMap.getField(&quot;map&quot;);</span><br><span class="line">            map.setAccessible(true);</span><br><span class="line">            &#x2F;&#x2F;noinspection unchecked</span><br><span class="line">            temp &#x3D; (HashMap&lt;String, HashMap&lt;String, Class&gt;&gt;) map.get(instance);</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            temp &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            collection &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;省略其他</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们注解库编写完成。</p><h3 id="4-使用"><a href="#4-使用" class="headerlink" title="4. 使用"></a>4. 使用</h3><p>android 项目举例</p><p>添加依赖：<br>implementation project(‘:mapper’)</p><p>声明注解器依赖：<br>annotationProcessor project(‘:mapper-compiler’)</p><p><strong>如果需要对 kotlin 类注解</strong>，先引入 kotlin 相关插件，<br>再添加 <code>apply plugin:&#39;kotlin-kapt&#39;</code>，将 annotationProcessor 替换为 kapt，即 <code>kapt project(&#39;:mapper-compiler&#39;)</code></p><p>新建类，添加注解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@MapType(name &#x3D; &quot;testA&quot;, group &#x3D; &quot;love&quot;)</span><br><span class="line">public class TestA &#123;</span><br><span class="line">    public TestA() &#123;</span><br><span class="line">        System.out.println(getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@MapType(name &#x3D; &quot;testB&quot;, array &#x3D; &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;)</span><br><span class="line">public class TestB &#123;</span><br><span class="line">    public TestB() &#123;</span><br><span class="line">        System.out.println(getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@MapType(name &#x3D; &quot;testC&quot;)</span><br><span class="line">public class TestC &#123;</span><br><span class="line">    public TestC() &#123;</span><br><span class="line">        System.out.println(getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务类中使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private void function()&#123;</span><br><span class="line">Class a &#x3D; Mapper.findItem(&quot;testA&quot;);</span><br><span class="line">&#x2F;&#x2F;具体逻辑，需做空判断</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-提交私仓-maven"><a href="#5-提交私仓-maven" class="headerlink" title="5. 提交私仓 maven"></a>5. 提交私仓 maven</h3><p>为了方便其他项目使用，我们可以把库提交到私仓，这里已假设存在私仓 maven。</p><h4 id="5-1-添加上传脚本"><a href="#5-1-添加上传脚本" class="headerlink" title="5.1 添加上传脚本"></a>5.1 添加上传脚本</h4><p>在两个 java-library 库均添加 maven 插件，并增加上传脚本，代码块如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &#39;maven&#39;</span><br><span class="line"></span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            repository(url: MAVEN_URL) &#123;</span><br><span class="line">                authentication(userName: USER_NAME, password: USER_PASSWORD)</span><br><span class="line">            &#125;</span><br><span class="line">            pom.project &#123;</span><br><span class="line">                groupId GROUP_ID&#x2F;&#x2F;定义的组</span><br><span class="line">                artifactId &#39;mapper-annotation&#39;&#x2F;&#x2F;库唯一标识</span><br><span class="line">                version &#39;1.0.0&#39;&#x2F;&#x2F;版本</span><br><span class="line">                packaging &#39;jar&#39;&#x2F;&#x2F;打包类型</span><br><span class="line">                description &#39;mapper-annotation&#39;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个库配置相似，区别在 artifactId 和 description 不同，版本号每次上传都需要改变。<br><strong>特别注意，上传jar不要用 SNAPSHOT 标识，每次上传都需要修改版本，相同版本无法覆盖！！如果使用，即使提示上传成功，你在引用的时候除非指定到特定版本，如 <code>implementation &#39;com.lib:mapper-annotation:1.0.1-20200711.111827-1&#39;</code>,否则不能准确获取最新的版本！</strong><br>配置不需要增加什么 task sourceJar，除非你完全理解 gradle task，否则有可能出现无法理解问题</p><p>当然，mapper 库也需要提交，增加配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &#39;maven&#39;</span><br><span class="line"></span><br><span class="line">task sourcesJar(type: Jar) &#123;</span><br><span class="line">    baseName &quot;mapper&quot;</span><br><span class="line">    &#x2F;&#x2F;分类器，用于区别其他jar包</span><br><span class="line">    classifier &quot;sources&quot;</span><br><span class="line">    &#x2F;&#x2F;从main源集中的所有代码</span><br><span class="line">    from android.sourceSets.main.java.srcDirs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">artifacts &#123;</span><br><span class="line">    archives sourcesJar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            repository(url: MAVEN_URL) &#123;</span><br><span class="line">                authentication(userName: USER_NAME, password: USER_PASSWORD)</span><br><span class="line">            &#125;</span><br><span class="line">            pom.project &#123;</span><br><span class="line">                groupId GROUP_ID</span><br><span class="line">                artifactId &#39;mapper&#39;</span><br><span class="line">                version &#39;1.0.0&#39;</span><br><span class="line">                packaging &#39;aar&#39;</span><br><span class="line">                description &#39;mapper&#39;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-修改依赖"><a href="#5-2-修改依赖" class="headerlink" title="5.2 修改依赖"></a>5.2 修改依赖</h4><ol><li>mapper-annotation 库<br> 因为 mapper 和 mapper-compiler 均依赖注解</li><li>注解器 mapper-compiler<br> 修改依赖注解为线上版本</li><li>对外库 mapper<br> 修改依赖注解为线上版本</li></ol><h4 id="5-3-上传"><a href="#5-3-上传" class="headerlink" title="5.3 上传"></a>5.3 上传</h4><p>打开 idea gradle 控制面板，在 upload 中逐个上传。</p><p>在其他需要的项目中，添加 mapper 依赖，增加注解器即可。</p><p><a href="https://github.com/maxiaozhou1234/Mapper" target="_blank" rel="noopener">项目地址，点我查阅</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;java 自定义注解器，提交私仓 maven&lt;/p&gt;
&lt;h3 id=&quot;1-java-自定义注解器&quot;&gt;&lt;a href=&quot;#1-java-自定义注解器&quot; class=&quot;headerlink&quot; title=&quot;1. java 自定义注解器&quot;&gt;&lt;/a&gt;1. java 自定义注解器&lt;/
      
    
    </summary>
    
    
      <category term="android" scheme="https://maxiaozhou1234.github.io/categories/android/"/>
    
    
      <category term="java" scheme="https://maxiaozhou1234.github.io/tags/java/"/>
    
      <category term="android" scheme="https://maxiaozhou1234.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>【Android】无限循环ViewPager setCurrentItem 导致 ANR 分析</title>
    <link href="https://maxiaozhou1234.github.io/android/viewpager-anr/"/>
    <id>https://maxiaozhou1234.github.io/android/viewpager-anr/</id>
    <published>2020-04-24T09:28:43.000Z</published>
    <updated>2020-04-25T03:07:46.049Z</updated>
    
    <content type="html"><![CDATA[<p>无限循环 ViewPager setCurrentItem 导致 ANR 分析</p><h2 id="1-无限循环-ViewPager"><a href="#1-无限循环-ViewPager" class="headerlink" title="1. 无限循环 ViewPager"></a>1. 无限循环 ViewPager</h2><p>通过 adapter 的 getCount 返回一个足够大的数字，再初始化显示的item在中间位置，那么用户在左右滑动能够模拟出一个循环的显示界面。</p><h2 id="2-调用-setCurrentItem-卡顿"><a href="#2-调用-setCurrentItem-卡顿" class="headerlink" title="2. 调用 setCurrentItem 卡顿"></a>2. 调用 setCurrentItem 卡顿</h2><p>当我们设置的 getCount 是一个较小的数字时，调用该方法总能快速跳转到目标位置，但是 getCount 是一个大数，如 Integer.MAX_VALUE，那么在调用跳转时，很容易触发 anr。</p><h3 id="2-1-源码分析"><a href="#2-1-源码分析" class="headerlink" title="2.1 源码分析"></a>2.1 源码分析</h3><p>设置显示的item角标，最终调用 <code>void setCurrentItemInternal(int item, boolean smoothScroll, boolean always, int velocity)</code> 这个函数，看下这个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">void setCurrentItemInternal(int item, boolean smoothScroll, boolean always, int velocity) &#123;</span><br><span class="line">    if (mAdapter &#x3D;&#x3D; null || mAdapter.getCount() &lt;&#x3D; 0) &#123;</span><br><span class="line">        setScrollingCacheEnabled(false);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!always &amp;&amp; mCurItem &#x3D;&#x3D; item &amp;&amp; mItems.size() !&#x3D; 0) &#123;</span><br><span class="line">        setScrollingCacheEnabled(false);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (item &lt; 0) &#123;</span><br><span class="line">        item &#x3D; 0;</span><br><span class="line">    &#125; else if (item &gt;&#x3D; mAdapter.getCount()) &#123;</span><br><span class="line">        item &#x3D; mAdapter.getCount() - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    final int pageLimit &#x3D; mOffscreenPageLimit;</span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x2F;&#x2F;这个设置是最后铺满画面的判定，但如果是大数，这里就是一个隐藏的 ANR</span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">    if (item &gt; (mCurItem + pageLimit) || item &lt; (mCurItem - pageLimit)) &#123;</span><br><span class="line">        &#x2F;&#x2F; We are doing a jump by more than one page.  To avoid</span><br><span class="line">        &#x2F;&#x2F; glitches, we want to keep all current pages in the view</span><br><span class="line">        &#x2F;&#x2F; until the scroll ends.</span><br><span class="line">        for (int i &#x3D; 0; i &lt; mItems.size(); i++) &#123;</span><br><span class="line">            mItems.get(i).scrolling &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    final boolean dispatchSelected &#x3D; mCurItem !&#x3D; item;</span><br><span class="line"></span><br><span class="line">    if (mFirstLayout) &#123;</span><br><span class="line">        &#x2F;&#x2F; We don&#39;t have any idea how big we are yet and shouldn&#39;t have any pages either.</span><br><span class="line">        &#x2F;&#x2F; Just set things up and let the pending layout handle things.</span><br><span class="line">        mCurItem &#x3D; item;</span><br><span class="line">        if (dispatchSelected) &#123;</span><br><span class="line">            dispatchOnPageSelected(item);</span><br><span class="line">        &#125;</span><br><span class="line">        requestLayout();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">&#x2F;&#x2F;重要方法，添加移除item！ANR的分析重点</span><br><span class="line">        populate(item);</span><br><span class="line">&#x2F;&#x2F;滑动到目标点</span><br><span class="line">        scrollToItem(item, smoothScroll, velocity, dispatchSelected);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面可以看到，首先会先根据当前位置和目标位置距离判断是否需要滑动item，如果是滑动一页，不会触发设置scrolling，假如超过 pageLimit 泽一定会设置 scrolling = true。</p><p>第二个方法是 <code>populate(item)</code>，用于移除看不见的item，添加新的item，下面部分代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">void populate(int newCurrentItem) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;...省略很多代码</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Fill 3x the available width or up to the number of offscreen</span><br><span class="line">    &#x2F;&#x2F; pages requested to either side, whichever is larger.</span><br><span class="line">    &#x2F;&#x2F; If we have no current item we have no work to do.</span><br><span class="line">    if (curItem !&#x3D; null) &#123;</span><br><span class="line">        float extraWidthLeft &#x3D; 0.f;</span><br><span class="line">        int itemIndex &#x3D; curIndex - 1;</span><br><span class="line">        ItemInfo ii &#x3D; itemIndex &gt;&#x3D; 0 ? mItems.get(itemIndex) : null;</span><br><span class="line">        final int clientWidth &#x3D; getClientWidth();</span><br><span class="line">        final float leftWidthNeeded &#x3D; clientWidth &lt;&#x3D; 0 ? 0 :</span><br><span class="line">                2.f - curItem.widthFactor + (float) getPaddingLeft() &#x2F; (float) clientWidth;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x2F;&#x2F;curIndex 是 mItem 的最后一个item的位置，经过上面处理，已经在原来基础上增加了一个</span><br><span class="line">&#x2F;&#x2F;ii 是我们现在页面显示的item，这里处理当前页面之前的item是否需要销毁</span><br><span class="line">&#x2F;&#x2F;这里也很明显看出运算次数为 pos 次，当设置是一个大数是，2^32 ≈ 8^10 约等于 10^10</span><br><span class="line">&#x2F;&#x2F;那么这里将执行总数的一半次数，估计 10^9 次</span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">        for (int pos &#x3D; mCurItem - 1; pos &gt;&#x3D; 0; pos--) &#123;</span><br><span class="line">            if (extraWidthLeft &gt;&#x3D; leftWidthNeeded &amp;&amp; pos &lt; startPos) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当 ii 为null时，能够跳出循环，ii的更新在下面的判断块中</span><br><span class="line">                if (ii &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;只有条件成立才会更新ii，但上面说到，如果更新的位置在pageLimit之内，</span><br><span class="line">&#x2F;&#x2F;scrolling 为false，超出则是true，超出的时候为了保证界面能完全填充</span><br><span class="line">&#x2F;&#x2F;也就是说无法跳出循环，所以在大数的时候，这里才是导致 ANR 的根本原因</span><br><span class="line">                if (pos &#x3D;&#x3D; ii.position &amp;&amp; !ii.scrolling) &#123;</span><br><span class="line">                    mItems.remove(itemIndex);</span><br><span class="line">                    mAdapter.destroyItem(this, pos, ii.object);</span><br><span class="line">                    if (DEBUG) &#123;</span><br><span class="line">                        Log.i(TAG, &quot;populate() - destroyItem() with pos: &quot; + pos</span><br><span class="line">                                + &quot; view: &quot; + ((View) ii.object));</span><br><span class="line">                    &#125;</span><br><span class="line">                    itemIndex--;</span><br><span class="line">                    curIndex--;</span><br><span class="line">                    ii &#x3D; itemIndex &gt;&#x3D; 0 ? mItems.get(itemIndex) : null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (ii !&#x3D; null &amp;&amp; pos &#x3D;&#x3D; ii.position) &#123;</span><br><span class="line">                extraWidthLeft +&#x3D; ii.widthFactor;</span><br><span class="line">                itemIndex--;</span><br><span class="line">                ii &#x3D; itemIndex &gt;&#x3D; 0 ? mItems.get(itemIndex) : null;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ii &#x3D; addNewItem(pos, itemIndex + 1);</span><br><span class="line">                extraWidthLeft +&#x3D; ii.widthFactor;</span><br><span class="line">                curIndex++;</span><br><span class="line">                ii &#x3D; itemIndex &gt;&#x3D; 0 ? mItems.get(itemIndex) : null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        float extraWidthRight &#x3D; curItem.widthFactor;</span><br><span class="line">        itemIndex &#x3D; curIndex + 1;</span><br><span class="line">        if (extraWidthRight &lt; 2.f) &#123;</span><br><span class="line">            ii &#x3D; itemIndex &lt; mItems.size() ? mItems.get(itemIndex) : null;</span><br><span class="line">            final float rightWidthNeeded &#x3D; clientWidth &lt;&#x3D; 0 ? 0 :</span><br><span class="line">                    (float) getPaddingRight() &#x2F; (float) clientWidth + 2.f;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这里同理，上面是判断设置的新页面在右边时，对当前页的左边进行处理</span><br><span class="line">&#x2F;&#x2F;下面代码是对当前页面右边的处理，一般执行次数为 pageLimit</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果新页面位置在当前页的右边，下面只会执行 pageLimit 次就跳出循环，因为pos+pageLimit 后的ii是null</span><br><span class="line">&#x2F;&#x2F;同理，如果新页面在当前页的左边，上面也只会执行1次就跳出，因为 pos-pageLimit 的ii是null</span><br><span class="line">            for (int pos &#x3D; mCurItem + 1; pos &lt; N; pos++) &#123;</span><br><span class="line">                if (extraWidthRight &gt;&#x3D; rightWidthNeeded &amp;&amp; pos &gt; endPos) &#123;</span><br><span class="line">                    if (ii &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (pos &#x3D;&#x3D; ii.position &amp;&amp; !ii.scrolling) &#123;</span><br><span class="line">                        mItems.remove(itemIndex);</span><br><span class="line">                        mAdapter.destroyItem(this, pos, ii.object);</span><br><span class="line">                        if (DEBUG) &#123;</span><br><span class="line">                            Log.i(TAG, &quot;populate() - destroyItem() with pos: &quot; + pos</span><br><span class="line">                                    + &quot; view: &quot; + ((View) ii.object));</span><br><span class="line">                        &#125;</span><br><span class="line">                        ii &#x3D; itemIndex &lt; mItems.size() ? mItems.get(itemIndex) : null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (ii !&#x3D; null &amp;&amp; pos &#x3D;&#x3D; ii.position) &#123;</span><br><span class="line">                    extraWidthRight +&#x3D; ii.widthFactor;</span><br><span class="line">                    itemIndex++;</span><br><span class="line">                    ii &#x3D; itemIndex &lt; mItems.size() ? mItems.get(itemIndex) : null;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    ii &#x3D; addNewItem(pos, itemIndex);</span><br><span class="line">                    itemIndex++;</span><br><span class="line">                    extraWidthRight +&#x3D; ii.widthFactor;</span><br><span class="line">                    ii &#x3D; itemIndex &lt; mItems.size() ? mItems.get(itemIndex) : null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        calculatePageOffsets(curItem, curIndex, oldCurInfo);</span><br><span class="line"></span><br><span class="line">        mAdapter.setPrimaryItem(this, mCurItem, curItem.object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;...省略很多代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面注释说明非常清楚，通过对 <strong>pos</strong>和<strong>scrolling</strong>判断，来决定是否销毁当前页的前/后数据，这里程序只会循环 currentItem 次，原本我猜测即使空转，那应该也会很快处理完成，但在大数面前，任何的空转都应当理性对待。</p><p>假设 1w 次循环耗时为0.04ms，那么被放大10^5，也会达到4s，当设置为大数时，这个循环的时间不可忽视。</p><p>为了更加严谨，我在<code>void populate(int newCurrentItem)</code> 前后加入时间埋点，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">public class AspectVp &#123;</span><br><span class="line">    private long time &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    @Before(&quot;call(void populate(..))&quot;)</span><br><span class="line">    public void beforePopulate(JoinPoint joinPoint) &#123;</span><br><span class="line">        if (joinPoint.getArgs().length &gt; 0) &#123;</span><br><span class="line">            Log.d(&quot;zhou&quot;, &quot;AspectVp [before populate &gt;&gt; &quot; + (time &#x3D; System.currentTimeMillis()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @After(&quot;call(void populate(..))&quot;)</span><br><span class="line">    public void afterPopulate(JoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">        if (joinPoint.getArgs().length &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">            long t &#x3D; System.currentTimeMillis();</span><br><span class="line">            Log.i(&quot;zhou&quot;, &quot;AspectVp [after  populate &gt;&gt; &quot; + t + &quot; &#x3D;&#x3D;&#x3D; spend &#x3D; &quot;</span><br><span class="line">                    + (t - time) + &quot; ms&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当设置个数为 20000，当前页为10000，跳转到 cur+10 位置，单次执行耗时 11<del>27 ms，如图1所示；<br>当设置个数为 2^32，当前页为 2^31 ，跳转到 cur+10 位置，单次执行耗时 3267</del>4193 ms，如图2所示：</p><p>图1：个数 20000</p><p><img src="https://i.loli.net/2020/04/24/WyOU1dhil7qBV2D.gif" alt="vp_small.gif"></p><p>图2：个数 2^32</p><p><img src="https://i.loli.net/2020/04/24/gyZ17rxLIFK9Hdn.gif" alt="vp_big.gif"></p><p>而且，从日志也可以看出，一次超缓存数的跳转，会触发四次 <code>populate(item)</code> 的调用。</p><p>1.setCurrentItem -&gt;  触发 populate(item)<br>2.populate(item) 有新item加入 -&gt; 触发 onMeasure -&gt; populate()<br>3.populate() -&gt; populate(item)<br>   | — 有可能再次判定加入新 item，跳转2，但下一次肯定不会有新的item需要添加<br>   | — 没有新增的 item<br>4.最后滑动结束，发出一个 populate() 保证页面覆盖完全</p><p>所以，3再会触发一次 <code>populate()</code>，但3-2-3不会成为死循环，总共有4次调用</p><h3 id="2-2-解决思路"><a href="#2-2-解决思路" class="headerlink" title="2.2 解决思路"></a>2.2 解决思路</h3><p>处理这个问题，有简单的方法，因为设置大数 2^32 真的太大了，修改为小一点、用户感知不强的数字，如10000,而5千次的滑动对用户也算是大操作，并且这个循环耗时在一个可接受范围，也不会造成页面的卡顿甚至 ANR。</p><p>或者，当设置的item超过pageLimit，我们强制把 isSrolling 设置为false，那么在遍历缓存 mItem 时能够及时更新 ii，使我们及时打破循环，跳出无用的循环时间。</p><h2 id="3-具体方案：打破循环"><a href="#3-具体方案：打破循环" class="headerlink" title="3. 具体方案：打破循环"></a>3. 具体方案：打破循环</h2><p>打破循环，让 <code>for (int pos = mCurItem - 1; pos &gt;= 0; pos--)</code> 和 <code>for (int pos = mCurItem + 1; pos &lt; N; pos++)</code> 尽快结束循环</p><h3 id="3-1-设置有限的小数（相对-2-32-来说）"><a href="#3-1-设置有限的小数（相对-2-32-来说）" class="headerlink" title="3.1 设置有限的小数（相对 2^32 来说）"></a>3.1 设置有限的小数（相对 2^32 来说）</h3><p>adapter 设置 getCount 为小数值，让循环基数降低，即使执行次数多，所等待的时间也处于可接受范围</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Adapter extends PagerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;...省略其他代码</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getCount() &#123;</span><br><span class="line">        return 10000;&#x2F;&#x2F;自行设置一个合理的数值</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;...省略其他代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-不触发设置-scrolling-条件"><a href="#3-2-不触发设置-scrolling-条件" class="headerlink" title="3.2 不触发设置 scrolling 条件"></a>3.2 不触发设置 scrolling 条件</h3><p>在 setCurrentItem 后，只要设置的 newIndex 在区间 <strong>(currentItem-pageLimit,currentItem+pageLimit)</strong>，就不会触发设置该条件，那么在调用设置之前，把 pageLimit 设置为 <strong>Math.abs(newIndex - currentItem)</strong>，调用设置位置之后，再重置回去，同样可以达到秒跳转效果，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;原调用 viewPager.setCurrentItem(newIndex, true); 修改如下</span><br><span class="line"></span><br><span class="line">int tmp &#x3D; viewPager.getOffscreenPageLimit();</span><br><span class="line">int newIndex &#x3D; viewPager.getCurrentItem() + 10;</span><br><span class="line">            </span><br><span class="line">int newLimit &#x3D; Math.abs(newIndex-viewPager.getCurrentItem());</span><br><span class="line">if(newLimit&gt;tmp) &#123;</span><br><span class="line">    viewPager.setOffscreenPageLimit(newLimit);</span><br><span class="line">    viewPager.setCurrentItem(newIndex, true);</span><br><span class="line">    viewPager.setOffscreenPageLimit(tmp);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    viewPager.setCurrentItem(newIndex, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-重置-scrolling-为-false"><a href="#3-3-重置-scrolling-为-false" class="headerlink" title="3.3 重置 scrolling 为 false"></a>3.3 重置 scrolling 为 false</h3><p>在设置完 setCurrentItem 后，由于跳转距离问题会将 scrolling 置为 true，所以在执行 <code>void populate(int newCurrentItem)</code> 之前把 scrolling 重置为 false，但是 mItems 是私有变量，需通过反射获取，再通过 AspectJ 埋点在执行之前遍历重置 scrolling，这么看来，无疑方法二是最快解决问题的方式。</p><p>以下代码仅供参考，请不要随意应用于生产环境，确定使用请仔细评估性能消耗，完成覆盖测试</p><p><strong>！注意：这里的注入对象是所有的 ViewPager！！</strong></p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">public class AspectVp &#123;</span><br><span class="line">    private long time &#x3D; 0;</span><br><span class="line">    private static ArrayList&lt;Object&gt; items &#x3D; null;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;反射获取</span><br><span class="line">    public static void setupViewPager(ViewPager viewPager) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Field field &#x3D; viewPager.getClass().getDeclaredField(&quot;mItems&quot;);</span><br><span class="line">            field.setAccessible(true);</span><br><span class="line">            items &#x3D; (ArrayList&lt;Object&gt;) field.get(viewPager);</span><br><span class="line">        &#125; catch (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(&quot;zhou&quot;, &quot;setupViewPager &quot; + (items &#x3D;&#x3D; null ? &quot;null&quot; : items.size()));</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;及时销毁</span><br><span class="line">    public static void destroyItems() &#123;</span><br><span class="line">        items &#x3D; null;</span><br><span class="line">        Log.i(&quot;zhou&quot;, &quot;destroyItems &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Before(&quot;call(void populate(..))&quot;)</span><br><span class="line">    public void beforePopulate(JoinPoint joinPoint) &#123;</span><br><span class="line">        if (joinPoint.getArgs().length &gt; 0) &#123;</span><br><span class="line">            Log.d(&quot;zhou&quot;, &quot;AspectVp [before populate &gt;&gt; &quot; + (time &#x3D; System.currentTimeMillis()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @After(&quot;call(void populate(..))&quot;)</span><br><span class="line">    public void afterPopulate(JoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">        if (joinPoint.getArgs().length &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">            long t &#x3D; System.currentTimeMillis();</span><br><span class="line">            Log.i(&quot;zhou&quot;, &quot;AspectVp [after  populate &gt;&gt; &quot; + t + &quot; &#x3D;&#x3D;&#x3D; spend &#x3D; &quot;</span><br><span class="line">                    + (t - time) + &quot; ms&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Before(&quot;execution(void populate(..))&quot;)</span><br><span class="line">    public void executionBefore(JoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">        if (joinPoint.getArgs().length &gt; 0 &amp;&amp; items !&#x3D; null) &#123;</span><br><span class="line">            for (Object obj : items) &#123;&#x2F;&#x2F;强制重置为false</span><br><span class="line">                Field scrolling &#x3D; obj.getClass().getDeclaredField(&quot;scrolling&quot;);</span><br><span class="line">                scrolling.setAccessible(true);</span><br><span class="line">                scrolling.set(obj, false);</span><br><span class="line">            &#125;</span><br><span class="line">            Log.i(&quot;zhou&quot;, &quot;executionBefore [&quot; + items.size() + &quot;]&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调用</span><br><span class="line">class MainActivity extent Activity&#123;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line">protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">&#x2F;&#x2F;省略其他</span><br><span class="line"></span><br><span class="line">        AspectVp.setupViewPager(viewPager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onStop() &#123;</span><br><span class="line">        super.onStop();</span><br><span class="line">&#x2F;&#x2F;销毁</span><br><span class="line">        AspectVp.destroyItems();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果如下：</p><p><img src="https://i.loli.net/2020/04/24/gUDyE1jeSn6OsoQ.gif" alt="vp_asept.gif"></p><p>完。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;无限循环 ViewPager setCurrentItem 导致 ANR 分析&lt;/p&gt;
&lt;h2 id=&quot;1-无限循环-ViewPager&quot;&gt;&lt;a href=&quot;#1-无限循环-ViewPager&quot; class=&quot;headerlink&quot; title=&quot;1. 无限循环 ViewP
      
    
    </summary>
    
    
      <category term="android" scheme="https://maxiaozhou1234.github.io/categories/android/"/>
    
    
      <category term="android" scheme="https://maxiaozhou1234.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>【Android】PagerAdapter不刷新问题分析</title>
    <link href="https://maxiaozhou1234.github.io/android/pager-adapter/"/>
    <id>https://maxiaozhou1234.github.io/android/pager-adapter/</id>
    <published>2020-04-22T14:50:10.000Z</published>
    <updated>2020-04-22T16:11:58.281Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用-PagerAdapter-notifyDataSetChange-不刷新问题分析"><a href="#使用-PagerAdapter-notifyDataSetChange-不刷新问题分析" class="headerlink" title="使用 PagerAdapter notifyDataSetChange 不刷新问题分析"></a>使用 PagerAdapter notifyDataSetChange 不刷新问题分析</h2><p>无论是普通的 ViewPager 视图，还是用 Fragment，当我们刷新数据后调用 notifyDataSetChange 后，往往会发现当前界面并没有预想的触发刷新，根本原因在于 ViewPager 的缓存机制判定数据未发生变化，从而不触发刷新，及时数据确实发生了改变。</p><h3 id="1-未触发刷新效果及分析"><a href="#1-未触发刷新效果及分析" class="headerlink" title="1. 未触发刷新效果及分析"></a>1. 未触发刷新效果及分析</h3><p>假设当前 page 是第一页，第一个数据发生变更，此时调用 notifyDataSetChange 后页面并没有变化，原因在于当前页面没有触发强制刷新，仅仅是从缓存中取数据而已。</p><h4 id="1-1-不刷新模拟效果"><a href="#1-1-不刷新模拟效果" class="headerlink" title="1.1 不刷新模拟效果"></a>1.1 不刷新模拟效果</h4><p>ViewPager 默认缓存数是1，即当前页+缓存，总共2，从效果图也可以看出更新数据后，当前页和滑动一页并不会销毁改页，在两页之后回到第一页，之前的页才被销毁，重新创建。</p><p>此页面有三个 view 在 ViewPager 中，当点击按钮会更新第一个 view 中的文字，在没有重写 getItemPosition 下，效果如下所示</p><p><img src="https://i.loli.net/2020/04/22/OgJVmaLwPqNjShb.gif" alt="vp_2.gif"></p><h4 id="1-2-不刷新源码分析"><a href="#1-2-不刷新源码分析" class="headerlink" title="1.2 不刷新源码分析"></a>1.2 不刷新源码分析</h4><p>当然，我们可以从 ViewPager 中看到，当我们调用 notifyDataSetChange 后会回调 VP 的 <code>void dataSetChanged()</code>，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">void dataSetChanged() &#123;</span><br><span class="line">&#x2F;&#x2F; This method only gets called if our observer is attached, so mAdapter is non-null.</span><br><span class="line"></span><br><span class="line">    final int adapterCount &#x3D; mAdapter.getCount();</span><br><span class="line">    mExpectedAdapterCount &#x3D; adapterCount;</span><br><span class="line">    boolean needPopulate &#x3D; mItems.size() &lt; mOffscreenPageLimit * 2 + 1</span><br><span class="line">            &amp;&amp; mItems.size() &lt; adapterCount;</span><br><span class="line">    int newCurrItem &#x3D; mCurItem;</span><br><span class="line"></span><br><span class="line">    boolean isUpdating &#x3D; false;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; mItems.size(); i++) &#123;</span><br><span class="line">        final ItemInfo ii &#x3D; mItems.get(i);</span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;核心方法&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">        final int newPos &#x3D; mAdapter.getItemPosition(ii.object);</span><br><span class="line"></span><br><span class="line">        if (newPos &#x3D;&#x3D; PagerAdapter.POSITION_UNCHANGED) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (newPos &#x3D;&#x3D; PagerAdapter.POSITION_NONE) &#123;</span><br><span class="line">            mItems.remove(i);</span><br><span class="line">            i--;</span><br><span class="line"></span><br><span class="line">            if (!isUpdating) &#123;</span><br><span class="line">                mAdapter.startUpdate(this);</span><br><span class="line">                isUpdating &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mAdapter.destroyItem(this, ii.position, ii.object);</span><br><span class="line">            needPopulate &#x3D; true;</span><br><span class="line"></span><br><span class="line">            if (mCurItem &#x3D;&#x3D; ii.position) &#123;</span><br><span class="line">                &#x2F;&#x2F; Keep the current item in the valid range</span><br><span class="line">                newCurrItem &#x3D; Math.max(0, Math.min(mCurItem, adapterCount - 1));</span><br><span class="line">                needPopulate &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">&#x2F;&#x2F;...省略一大堆</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;...省略一大堆</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会遍历所有缓存，通过 <code>mAdapter.getItemPosition(obj)</code> 判断是否需要销毁重建，该方法默认值 <code>POSITION_UNCHANGED</code> 为-1，即默认数据没有变化。所以我们只需要重写这个方法，确定当前位置的数据是否应该销毁，当然有很多 demo 都是直接建议销毁，即返回 POSITION_NONE。本身 ViewPager 设计并不是为频繁变化的数据，所以数据变化频繁或者为了性能更好，尽可能使用 RecyclerView + PagerSnapHelper 替换 VP。</p><h4 id="1-3-重写-adapter-中方法实现刷新"><a href="#1-3-重写-adapter-中方法实现刷新" class="headerlink" title="1.3 重写 adapter 中方法实现刷新"></a>1.3 重写 adapter 中方法实现刷新</h4><p>好，为了继续使用 VP 来更新，应该动态的判断这个 <code>getItemPosition</code>，本身 VP 性能一般，一刀切不适合这种场景，所以我们通过 <code>setTag</code> 来解决这个数据关联问题，如下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;HashMap&lt;String, String&gt;&gt; data &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">class Adapter extends PagerAdapter &#123;</span><br><span class="line">&#x2F;&#x2F;...省略其他方法</span><br><span class="line">@NonNull</span><br><span class="line">    @Override</span><br><span class="line">    public Object instantiateItem(@NonNull ViewGroup container, int position) &#123;</span><br><span class="line">        TextView view &#x3D; (TextView) LayoutInflater.from(ViewPagerActivity.this).inflate(R.layout.layout_simple_text, container, false);</span><br><span class="line">        String text &#x3D; data.get(position).get(&quot;name&quot;);</span><br><span class="line">        view.setText(text);</span><br><span class="line">        view.setTag(-1, position);</span><br><span class="line">        view.setTag(-2, text);</span><br><span class="line">        container.addView(view);</span><br><span class="line">        return view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getItemPosition(@NonNull Object object) &#123;</span><br><span class="line">        if (getCount() &#x3D;&#x3D; 0)</span><br><span class="line">            return POSITION_UNCHANGED;</span><br><span class="line">        View view &#x3D; (View) object;</span><br><span class="line">        int pos &#x3D; (int) view.getTag(-1);</span><br><span class="line">        String msg &#x3D; (String) view.getTag(-2);</span><br><span class="line">        if (pos &gt;&#x3D; getCount()) &#123;</span><br><span class="line">            return POSITION_NONE;</span><br><span class="line">        &#125;</span><br><span class="line">        return msg.equals(data.get(pos).get(&quot;name&quot;)) ? POSITION_UNCHANGED : POSITION_NONE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更改之后效果图：</p><p>在判断之后，数据修改之后可以及时反馈到界面上，代价是需要数据源标记原始数据位置，但仅仅是一个4位的int</p><p><img src="https://i.loli.net/2020/04/22/OgJVmaLwPqNjShb.gif" alt="vp_2.gif"></p><h3 id="2-为什么还要使用-PagerAdapter？"><a href="#2-为什么还要使用-PagerAdapter？" class="headerlink" title="2. 为什么还要使用 PagerAdapter？"></a>2. 为什么还要使用 PagerAdapter？</h3><p>ViewPager 在普通的 View 页面，在今天，使用空间其实很小了，但在 Fragment 组合页面，配合 FragmentPagerAdapter，不得不说非常方便，如果在存在需要动态增减 Fragment，使用 <code>getItemPosition（obj）</code> 来减少创建销毁还是比较合适，当然使用场景是固定几个 fragment （2-3个）配合<code>setOffscreenPageLimit</code>缓存可以一次创建足够，如果有一堆页面（超过设置的缓存数量），这个创建销毁过程的消耗还是客观存在，不容小觑。</p><h3 id="3-FragmentPagerAdapter-改造，更适合-Fragment-增减"><a href="#3-FragmentPagerAdapter-改造，更适合-Fragment-增减" class="headerlink" title="3. FragmentPagerAdapter 改造，更适合 Fragment 增减"></a>3. FragmentPagerAdapter 改造，更适合 Fragment 增减</h3><h4 id="3-1-Fragment-创建"><a href="#3-1-Fragment-创建" class="headerlink" title="3.1 Fragment 创建"></a>3.1 Fragment 创建</h4><p>使用 <code>FragmentPagerAdapter</code> 有页面替换需要，除了重写 <code>getItemPosition()</code> 还需要重写 <code>getItemId(position)</code>。为什么？因为 <code>fragment</code> 存在于 <code>FragmentManager</code> 中，通过 <code>mFragmentManager.findFragmentByTag(name)</code> 来找到之前的 fragment，也可以理解为** fragment 的缓存**，具体源码代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiateItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCurTransaction == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mCurTransaction = mFragmentManager.beginTransaction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> itemId = getItemId(position);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do we already have this fragment?</span></span><br><span class="line">    String name = makeFragmentName(container.getId(), itemId);</span><br><span class="line">    Fragment fragment = mFragmentManager.findFragmentByTag(name);</span><br><span class="line">    <span class="keyword">if</span> (fragment != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Attaching item #"</span> + itemId + <span class="string">": f="</span> + fragment);</span><br><span class="line">        mCurTransaction.attach(fragment);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fragment = getItem(position);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Adding item #"</span> + itemId + <span class="string">": f="</span> + fragment);</span><br><span class="line">        mCurTransaction.add(container.getId(), fragment,</span><br><span class="line">                makeFragmentName(container.getId(), itemId));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fragment != mCurrentPrimaryItem) &#123;</span><br><span class="line">        fragment.setMenuVisibility(<span class="keyword">false</span>);</span><br><span class="line">        fragment.setUserVisibleHint(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fragment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有重写该方法，那么，在增减数据后，即使 <code>getItemPosition</code> 判定数据变化，再通过 <code>makeFragmentName(container.getId(), itemId)</code> （itemId 默认是position）获取的 tag 还是不变，那么重新拿到的 fragment 和原来位置的 fragment 一样，，所以必须通过重写 <code>getItemId</code> 来修改 tag，使这数据源中的 fragment 和这个 tag 形成唯一个关联关系，一般唯一性用hashCode就足够了。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Fragment&gt; data = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageAdapter</span> <span class="keyword">extends</span> <span class="title">FragmentPagerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    PageAdapter(FragmentManager fm) &#123;</span><br><span class="line">        <span class="keyword">super</span>(fm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fragment <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        SimpleFragment fragment = (SimpleFragment) data.get(position);</span><br><span class="line">        fragment.setPosition(position);</span><br><span class="line">        <span class="keyword">return</span> fragment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getItemId</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.get(position).hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemPosition</span><span class="params">(@NonNull Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getCount() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> POSITION_UNCHANGED;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> position = ((SimpleFragment) object).getPosition();</span><br><span class="line">        <span class="keyword">if</span> (position &gt;= getCount()) &#123;</span><br><span class="line">            <span class="keyword">return</span> POSITION_NONE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data.get(position).hashCode() == object.hashCode() ? POSITION_UNCHANGED : POSITION_NONE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong> SimpleFragment 只是继承 Fragment 增加一个 position 参数及相应方法。</p><h4 id="3-2-适配器修改前后效果图示"><a href="#3-2-适配器修改前后效果图示" class="headerlink" title="3.2 适配器修改前后效果图示"></a>3.2 适配器修改前后效果图示</h4><p>效果图：操作中的删除为 data.remove(1);//删除第二个数据</p><p>1.仅修改 getItemPosition</p><p><img src="https://i.loli.net/2020/04/22/bAvY6T1UgLHkFEh.gif" alt="vp_3.gif"></p><p>2.修改 getItemPosition 和 getItemId</p><p><img src="https://i.loli.net/2020/04/22/3K61nlM5RjyPaQF.gif" alt="vp_5.gif"></p><p>完。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用-PagerAdapter-notifyDataSetChange-不刷新问题分析&quot;&gt;&lt;a href=&quot;#使用-PagerAdapter-notifyDataSetChange-不刷新问题分析&quot; class=&quot;headerlink&quot; title=&quot;使用 Pag
      
    
    </summary>
    
    
      <category term="android" scheme="https://maxiaozhou1234.github.io/categories/android/"/>
    
    
      <category term="android" scheme="https://maxiaozhou1234.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>【sqlite】测试题</title>
    <link href="https://maxiaozhou1234.github.io/sqlite/sqlite-test/"/>
    <id>https://maxiaozhou1234.github.io/sqlite/sqlite-test/</id>
    <published>2020-02-26T06:54:21.000Z</published>
    <updated>2020-04-22T15:56:40.687Z</updated>
    
    <content type="html"><![CDATA[<p>数据库测试题</p><h3 id="数据库测试，写出对应的操作-sql-语句"><a href="#数据库测试，写出对应的操作-sql-语句" class="headerlink" title="数据库测试，写出对应的操作 sql 语句"></a>数据库测试，写出对应的操作 sql 语句</h3><h4 id="1-筛选出表A和表B中列【id-name-age】去重后合并输出"><a href="#1-筛选出表A和表B中列【id-name-age】去重后合并输出" class="headerlink" title="1.筛选出表A和表B中列【id,name,age】去重后合并输出"></a>1.筛选出表A和表B中列【id,name,age】去重后合并输出</h4><p>合并选择 union/union all 去重 union<br>前提两个表均包含列【id,name,age】</p><p>select id,name,age from table_A union select id,name,age from table_B;</p><h4 id="2-表1和表2存在id关联关系，将两表列相关联数据全部输出"><a href="#2-表1和表2存在id关联关系，将两表列相关联数据全部输出" class="headerlink" title="2.表1和表2存在id关联关系，将两表列相关联数据全部输出"></a>2.表1和表2存在id关联关系，将两表列相关联数据全部输出</h4><ol><li>存在关联，明显是用 join</li><li>对于单表都有扩展的列，可以用 outer join，inner join</li><li>只要相关联数据，说明是两表都有的数据，使用 inner join。使用 outer join 输出会把缺少的补位 null，属于全量。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from company;</span><br><span class="line">+----+-------+------+------------+--------+</span><br><span class="line">| id | name  | age  | address    | salary |</span><br><span class="line">+----+-------+------+------------+--------+</span><br><span class="line">|  1 | Paul  |   32 | California |  20000 |</span><br><span class="line">|  2 | Allen |   25 | Texas      |  15000 |</span><br><span class="line">|  3 | Teddy |   23 | Norway     |  20000 |</span><br><span class="line">|  4 | Mark  |   25 | Rich-Mond  |  65000 |</span><br><span class="line">|  5 | David |   27 | Texas      |  85000 |</span><br><span class="line">|  6 | Kim   |   22 | South-Hall |  45000 |</span><br><span class="line">|  7 | James |   24 | Houston    |  10000 |</span><br><span class="line">|  8 | Kit   |   30 | NY         |  12000 |</span><br><span class="line">| 10 | Mike  |   17 | NY         |   2000 |</span><br><span class="line">+----+-------+------+------------+--------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from department;</span><br><span class="line">+----+-------------+--------+</span><br><span class="line">| id | dept        | emp_id |</span><br><span class="line">+----+-------------+--------+</span><br><span class="line">|  1 | IT Billing  |      1 |</span><br><span class="line">|  2 | Engineering |      2 |</span><br><span class="line">|  3 | Finance     |      7 |</span><br><span class="line">|  4 | Engineering |      3 |</span><br><span class="line">|  5 | Finance     |      4 |</span><br><span class="line">|  6 | Engineering |      5 |</span><br><span class="line">|  7 | Finance     |      6 |</span><br><span class="line">+----+-------------+--------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>使用 inner join 输出：</p><blockquote><p>mysql&gt; select c.id,c.name,c.salary,d.dept from company c inner join department d on c.id=d.emp_id;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+----+-------+--------+-------------+</span><br><span class="line">| id | name  | salary | dept        |</span><br><span class="line">+----+-------+--------+-------------+</span><br><span class="line">|  1 | Paul  |  20000 | IT Billing  |</span><br><span class="line">|  2 | Allen |  15000 | Engineering |</span><br><span class="line">|  7 | James |  10000 | Finance     |</span><br><span class="line">|  3 | Teddy |  20000 | Engineering |</span><br><span class="line">|  4 | Mark  |  65000 | Finance     |</span><br><span class="line">|  5 | David |  85000 | Engineering |</span><br><span class="line">|  6 | Kim   |  45000 | Finance     |</span><br><span class="line">+----+-------+--------+-------------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><hr><h2 id="对比外连接"><a href="#对比外连接" class="headerlink" title="对比外连接"></a><strong>对比外连接</strong></h2><p>1.使用 company 左外连接 department</p><blockquote><p>mysql&gt; select c.id,c.name,c.salary,d.dept from company c left outer join department d on c.id=d.emp_id;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+----+-------+--------+-------------+</span><br><span class="line">| id | name  | salary | dept        |</span><br><span class="line">+----+-------+--------+-------------+</span><br><span class="line">|  1 | Paul  |  20000 | IT Billing  |</span><br><span class="line">|  2 | Allen |  15000 | Engineering |</span><br><span class="line">|  3 | Teddy |  20000 | Engineering |</span><br><span class="line">|  4 | Mark  |  65000 | Finance     |</span><br><span class="line">|  5 | David |  85000 | Engineering |</span><br><span class="line">|  6 | Kim   |  45000 | Finance     |</span><br><span class="line">|  7 | James |  10000 | Finance     |</span><br><span class="line">|  8 | Kit   |  12000 | NULL        |</span><br><span class="line">| 10 | Mike  |   2000 | NULL        |</span><br><span class="line">+----+-------+--------+-------------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>2.使用 company 右外连接 department （sqlite不支持右外连接可以使用左外连接，调整两个表位置）</p><blockquote><p>mysql&gt; select c.id,c.name,c.salary,d.dept from company c right outer join department d on c.id=d.emp_id;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+------+-------+--------+-------------+</span><br><span class="line">| id   | name  | salary | dept        |</span><br><span class="line">+------+-------+--------+-------------+</span><br><span class="line">|    1 | Paul  |  20000 | IT Billing  |</span><br><span class="line">|    2 | Allen |  15000 | Engineering |</span><br><span class="line">|    7 | James |  10000 | Finance     |</span><br><span class="line">|    3 | Teddy |  20000 | Engineering |</span><br><span class="line">|    4 | Mark  |  65000 | Finance     |</span><br><span class="line">|    5 | David |  85000 | Engineering |</span><br><span class="line">|    6 | Kim   |  45000 | Finance     |</span><br><span class="line">+------+-------+--------+-------------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>上面可以看到，外连接输出与左表、右表相关，题目只要相关联，使用inner join。</p><h4 id="3-表1和表2彼此独立，请列出两表的所有可能组合"><a href="#3-表1和表2彼此独立，请列出两表的所有可能组合" class="headerlink" title="3.表1和表2彼此独立，请列出两表的所有可能组合"></a>3.表1和表2彼此独立，请列出两表的所有可能组合</h4><p>交叉连接<br>select * from table_1 cross join table_2;</p><h4 id="4-表1为员工表，manager-id-为该员工领导id，请通过单表列出员工的-id-name-manager-name"><a href="#4-表1为员工表，manager-id-为该员工领导id，请通过单表列出员工的-id-name-manager-name" class="headerlink" title="4.表1为员工表，manager_id 为该员工领导id，请通过单表列出员工的[id,name,manager_name]"></a>4.表1为员工表，manager_id 为该员工领导id，请通过单表列出员工的[id,name,manager_name]</h4><p>mysql&gt; desc employ;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+------------+----------+------+-----+---------+-------+</span><br><span class="line">| Field      | Type     | Null | Key | Default | Extra |</span><br><span class="line">+------------+----------+------+-----+---------+-------+</span><br><span class="line">| id         | int(11)  | YES  |     | NULL    |       |</span><br><span class="line">| name       | char(20) | YES  |     | NULL    |       |</span><br><span class="line">| salary     | double   | YES  |     | NULL    |       |</span><br><span class="line">| manager_id | int(11)  | YES  |     | NULL    |       |</span><br><span class="line">+------------+----------+------+-----+---------+-------+</span><br><span class="line">4 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>mysql&gt; select * from employ;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+------+------+--------+------------+</span><br><span class="line">| id   | name | salary | manager_id |</span><br><span class="line">+------+------+--------+------------+</span><br><span class="line">|    1 | aa   |   2000 |          3 |</span><br><span class="line">|    2 | bb   |   1000 |          3 |</span><br><span class="line">|    3 | cc   |   2500 |          4 |</span><br><span class="line">|    4 | dd   |   6000 |        100 |</span><br><span class="line">|  100 | ee   |   6000 |          0 |</span><br><span class="line">|    5 | vv   |   3000 |        100 |</span><br><span class="line">+------+------+--------+------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>mysql&gt; select e.id,e.name,e2.name as manager_name from employ e,employ e2 where e.manager_id=e2.id;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+------+------+--------------+</span><br><span class="line">| id   | name | manager_name |</span><br><span class="line">+------+------+--------------+</span><br><span class="line">|    1 | aa   | cc           |</span><br><span class="line">|    2 | bb   | cc           |</span><br><span class="line">|    3 | cc   | dd           |</span><br><span class="line">|    4 | dd   | ee           |</span><br><span class="line">|    5 | vv   | ee           |</span><br><span class="line">+------+------+--------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="5-触发器，表1是用户数据表，uid是操作者id（假设是运维管理），id是新增用户id，需要把表1的增删改操作记录到表log中-uid操作者-action动作-id被操作对象-date时间"><a href="#5-触发器，表1是用户数据表，uid是操作者id（假设是运维管理），id是新增用户id，需要把表1的增删改操作记录到表log中-uid操作者-action动作-id被操作对象-date时间" class="headerlink" title="5.触发器，表1是用户数据表，uid是操作者id（假设是运维管理），id是新增用户id，需要把表1的增删改操作记录到表log中[uid操作者,action动作,id被操作对象,date时间]"></a>5.触发器，表1是用户数据表，uid是操作者id（假设是运维管理），id是新增用户id，需要把表1的增删改操作记录到表log中[uid操作者,action动作,id被操作对象,date时间]</h4><p>表1：create table user (id int primary key auto_increment,name char(20),age int check(age&gt;0),uid int);</p><p>mysql&gt; desc user;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-------+----------+------+-----+---------+----------------+</span><br><span class="line">| Field | Type     | Null | Key | Default | Extra          |</span><br><span class="line">+-------+----------+------+-----+---------+----------------+</span><br><span class="line">| id    | int(11)  | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| name  | char(20) | YES  |     | NULL    |                |</span><br><span class="line">| age   | int(11)  | YES  |     | NULL    |                |</span><br><span class="line">| uid   | int(11)  | YES  |     | NULL    |                |</span><br><span class="line">+-------+----------+------+-----+---------+----------------+</span><br><span class="line">4 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>表2：create table user_log (uid int,action char(20),id int,time timestamp default CURRENT_TIMESTAMP);</p><p>mysql&gt; desc user_log;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+--------+-----------+------+-----+-------------------+-------+</span><br><span class="line">| Field  | Type      | Null | Key | Default           | Extra |</span><br><span class="line">+--------+-----------+------+-----+-------------------+-------+</span><br><span class="line">| uid    | int(11)   | YES  |     | NULL              |       |</span><br><span class="line">| action | char(20)  | YES  |     | NULL              |       |</span><br><span class="line">| id     | int(11)   | YES  |     | NULL              |       |</span><br><span class="line">| time   | timestamp | NO   |     | CURRENT_TIMESTAMP |       |</span><br><span class="line">+--------+-----------+------+-----+-------------------+-------+</span><br><span class="line">4 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>创建触发器。由于 MySQL 5.5只支持单事件触发，所以需要三个对应触发器</p><ol><li><p>增</p><blockquote><p>mysql&gt; create trigger user_insert after insert on user<br> -&gt; for each row<br> -&gt; BEGIN<br> -&gt; insert into user_log(uid,action,id) values (new.uid,’create’,new.id);<br> -&gt; END;<br> -&gt; //<br>Query OK, 0 rows affected (0.06 sec)</p></blockquote></li><li><p>改</p><blockquote><p>mysql&gt; create trigger user_update after update on user<br> -&gt; for each row<br> -&gt; BEGIN<br> -&gt; insert into user_log(uid,action,id) values (old.uid,’update’,old.id);<br> -&gt; END;<br> -&gt; //<br>Query OK, 0 rows affected (0.05 sec)</p></blockquote></li><li><p>删</p><blockquote><p>mysql&gt; create trigger user_delete after delete on user<br> -&gt; for each row<br> -&gt; BEGIN<br> -&gt; insert into user_log(uid,action,id) values (old.uid,’delete’,old.id);<br> -&gt; END;<br> -&gt; //<br>Query OK, 0 rows affected (0.08 sec)</p></blockquote></li></ol><p>测试：</p><pre><code>mysql&gt; select * from user;Empty set (0.00 sec)mysql&gt; select * from user_log;Empty set (0.00 sec)mysql&gt; insert into user (uid,name,age)values (1000,&apos;aka&apos;,10);Query OK, 1 row affected (0.03 sec)mysql&gt; insert into user (uid,name,age)values (1000,&apos;mille&apos;,19);Query OK, 1 row affected (0.03 sec)mysql&gt; insert into user (uid,name,age)values (1003,&apos;jim&apos;,22);Query OK, 1 row affected (0.03 sec)mysql&gt; update user set name=&apos;Sare&apos; where id=&apos;1&apos;;Query OK, 1 row affected (0.02 sec)Rows matched: 1  Changed: 1  Warnings: 0mysql&gt; delete from user where id=2;Query OK, 1 row affected (0.03 sec)</code></pre><p>结果显示：<br>mysql&gt; select * from user;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+----+-------+------+------+</span><br><span class="line">| id | name | age  | uid  |</span><br><span class="line">+----+-------+------+------+</span><br><span class="line">|  1 | Sare |   10 | 1000 |</span><br><span class="line">|  3 | jim  |   22 | 1003 |</span><br><span class="line">+----+-------+------+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>mysql&gt; select * from user_log;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+------+--------+------+---------------------+</span><br><span class="line">| uid  | action | id   | time                |</span><br><span class="line">+------+--------+------+---------------------+</span><br><span class="line">| 1000 | create |    1 | 2020-02-26 10:59:26 |</span><br><span class="line">| 1000 | create |    2 | 2020-02-26 10:59:43 |</span><br><span class="line">| 1003 | create |    3 | 2020-02-26 11:00:12 |</span><br><span class="line">| 1000 | update |    1 | 2020-02-26 11:01:02 |</span><br><span class="line">| 1000 | delete |    2 | 2020-02-26 11:01:39 |</span><br><span class="line">+------+--------+------+---------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数据库测试题&lt;/p&gt;
&lt;h3 id=&quot;数据库测试，写出对应的操作-sql-语句&quot;&gt;&lt;a href=&quot;#数据库测试，写出对应的操作-sql-语句&quot; class=&quot;headerlink&quot; title=&quot;数据库测试，写出对应的操作 sql 语句&quot;&gt;&lt;/a&gt;数据库测试，写出对应的操
      
    
    </summary>
    
    
      <category term="sqlite" scheme="https://maxiaozhou1234.github.io/categories/sqlite/"/>
    
    
      <category term="sqlite" scheme="https://maxiaozhou1234.github.io/tags/sqlite/"/>
    
  </entry>
  
  <entry>
    <title>【sqlite】VIEW 视图</title>
    <link href="https://maxiaozhou1234.github.io/sqlite/sqlite-view/"/>
    <id>https://maxiaozhou1234.github.io/sqlite/sqlite-view/</id>
    <published>2020-02-25T10:08:50.000Z</published>
    <updated>2020-04-22T15:56:40.688Z</updated>
    
    <content type="html"><![CDATA[<p>sqlite view 视图</p><h3 id="View-视图"><a href="#View-视图" class="headerlink" title="View 视图"></a>View 视图</h3><p>视图（View）可以包含一个表的所有行或从一个或多个表选定行。视图（View）可以从一个或多个表创建，这取决于要创建视图的 SQLite 查询。</p><h4 id="1-创建视图语法"><a href="#1-创建视图语法" class="headerlink" title="1.创建视图语法"></a>1.创建视图语法</h4><blockquote><p>CREATE [TEMP | TEMPORARY] VIEW view_name AS<br>SELECT column1, column2…..<br>FROM table_name<br>WHERE [condition];</p></blockquote><h4 id="2-创建视图实例"><a href="#2-创建视图实例" class="headerlink" title="2.创建视图实例"></a>2.创建视图实例</h4><p>你可以只从一个表中取其中几列做为新视图，这里用两个表合并为一个视图。</p><blockquote><p>mysql&gt; create view company_view as select e.id,e.name,e.age,d.dept from company e inner join department d where e.id=d.e<br>mp_id;<br>Query OK, 0 rows affected (0.03 sec)   </p></blockquote><p> mysql&gt; select * from company_view;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+----+-------+------+-------------+</span><br><span class="line">| id | name  | age  | dept        |</span><br><span class="line">+----+-------+------+-------------+</span><br><span class="line">|  1 | Paul  |   32 | IT Billing  |</span><br><span class="line">|  2 | Allen |   25 | Engineering |</span><br><span class="line">|  7 | James |   24 | Finance     |</span><br><span class="line">|  3 | Teddy |   23 | Engineering |</span><br><span class="line">|  4 | Mark  |   25 | Finance     |</span><br><span class="line">|  5 | David |   27 | Engineering |</span><br><span class="line">|  6 | Kim   |   22 | Finance     |</span><br><span class="line">+----+-------+------+-------------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="3-删除视图"><a href="#3-删除视图" class="headerlink" title="3.删除视图"></a>3.删除视图</h4><blockquote><p>drop view view_name</p></blockquote><p>mysql&gt; show tables;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+</span><br><span class="line">| Tables_in_learn_db |</span><br><span class="line">+--------------------+</span><br><span class="line">| company            |</span><br><span class="line">| company_view       |</span><br><span class="line">| department         |</span><br><span class="line">| employ             |</span><br><span class="line">| log                |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><blockquote><p>mysql&gt; drop view company_view;<br>Query OK, 0 rows affected (0.00 sec)</p></blockquote><p>mysql&gt; show tables;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+</span><br><span class="line">| Tables_in_learn_db |</span><br><span class="line">+--------------------+</span><br><span class="line">| company            |</span><br><span class="line">| department         |</span><br><span class="line">| employ             |</span><br><span class="line">| log                |</span><br><span class="line">+--------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;sqlite view 视图&lt;/p&gt;
&lt;h3 id=&quot;View-视图&quot;&gt;&lt;a href=&quot;#View-视图&quot; class=&quot;headerlink&quot; title=&quot;View 视图&quot;&gt;&lt;/a&gt;View 视图&lt;/h3&gt;&lt;p&gt;视图（View）可以包含一个表的所有行或从一个或多个表选
      
    
    </summary>
    
    
      <category term="sqlite" scheme="https://maxiaozhou1234.github.io/categories/sqlite/"/>
    
    
      <category term="sqlite" scheme="https://maxiaozhou1234.github.io/tags/sqlite/"/>
    
  </entry>
  
  <entry>
    <title>【sqlite】Trigger 触发器</title>
    <link href="https://maxiaozhou1234.github.io/sqlite/sqlite-trigger/"/>
    <id>https://maxiaozhou1234.github.io/sqlite/sqlite-trigger/</id>
    <published>2020-02-25T05:34:25.000Z</published>
    <updated>2020-04-22T15:56:40.688Z</updated>
    
    <content type="html"><![CDATA[<p>sqlite Trigger 触发器</p><h3 id="Trigger-触发器"><a href="#Trigger-触发器" class="headerlink" title="Trigger 触发器"></a>Trigger 触发器</h3><p>SQLite 触发器（Trigger）是数据库的回调函数，它会在指定的数据库事件发生时自动执行/调用。<br>指定在特定的数据库表发生 DELETE、INSERT 或 UPDATE 时触发，或在一个或多个指定表的列发生更新时触发。</p><p><a href="https://www.runoob.com/sqlite/sqlite-trigger.html" target="_blank" rel="noopener">Trigger 详细资料链接</a></p><h4 id="1-语法"><a href="#1-语法" class="headerlink" title="1.语法"></a>1.语法</h4><blockquote><p>CREATE  TRIGGER trigger_name [BEFORE|AFTER] event_name[INSERT|UPDATE|DELETE] ON table_name<br>FOR EACH ROW（对 SQLite 可加可不加）<br>BEGIN<br> – 触发器逻辑….<br>END;</p></blockquote><h4 id="2-SQLite-使用触发器"><a href="#2-SQLite-使用触发器" class="headerlink" title="2.SQLite 使用触发器"></a>2.SQLite 使用触发器</h4><h5 id="1）创建记录表，用于存储触发后数据"><a href="#1）创建记录表，用于存储触发后数据" class="headerlink" title="1）创建记录表，用于存储触发后数据"></a>1）创建记录表，用于存储触发后数据</h5><p>create table log(uid int,entry_date text);</p><h5 id="2-创建触发器"><a href="#2-创建触发器" class="headerlink" title="2)创建触发器"></a>2)创建触发器</h5><p>create TRIGGER emp_log AFTER INSERT ON employ<br>BEGIN<br>INSERT INTO log(uid,rtime) values (new.id,datetime(‘now’,’localtime’));<br>END;</p><h5 id="3-向-employ-插入数据，查看log中记录"><a href="#3-向-employ-插入数据，查看log中记录" class="headerlink" title="3)向 employ 插入数据，查看log中记录"></a>3)向 employ 插入数据，查看log中记录</h5><blockquote><p>insert into employ values(5,’vv’,3000,100);</p></blockquote><p>因为没有创建新表，所以存在之前的数据，旧数据再触发器之前存在是不会新增记录在 log 表中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+------+------+--------+------------+</span><br><span class="line">| id   | name | salary | manager_id |</span><br><span class="line">+------+------+--------+------------+</span><br><span class="line">|    1 | aa   |   2000 |          3 |</span><br><span class="line">|    2 | bb   |   1000 |          3 |</span><br><span class="line">|    3 | cc   |   2500 |          4 |</span><br><span class="line">|    4 | dd   |   6000 |        100 |</span><br><span class="line">|  100 | ee   |   6000 |          0 |</span><br><span class="line">|    5 | vv   |   3000 |        100 |</span><br><span class="line">+------+------+--------+------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>log 中记录</p><blockquote><p>select * from log;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+------+----------------------+</span><br><span class="line">| uid  |     entry_date       |</span><br><span class="line">+------+----------------------+</span><br><span class="line">|5     | 2020-02-25 13: 07:02 |</span><br><span class="line">+------+----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="2-MySQL-使用触发器"><a href="#2-MySQL-使用触发器" class="headerlink" title="2.MySQL 使用触发器"></a>2.MySQL 使用触发器</h4><p>使用 MySQL 添加触发器语法和上面一致<br><strong>注意:</strong></p><ul><li>如果是在命令行中执行MySQL，需要将delimiter ; 更改为delimiter //，MySQL 默认使用分号 <strong>“;”</strong> 结束判断，不更改在遇到分号执行语句会导致提示语法错误导致创建触发器失败</li><li>需要增加 <strong>FOR EACH ROW</strong>， MySQL 不支持语句触发器,仅仅支持行级触发器，必须增加这句</li></ul><p>示例如下：</p><blockquote><p>mysql&gt; delimiter //<br>mysql&gt; CREATE TRIGGER emp_log AFTER INSERT ON employ<br>    -&gt; FOR EACH ROW<br>    -&gt; BEGIN<br>    -&gt; INSERT INTO log(uid) values (new.id);<br>    -&gt; END;<br>    -&gt; //<br>Query OK, 0 rows affected (0.08 sec)</p></blockquote><p>最后可以重新把分号执行修改回来，在命令行输入</p><blockquote><p>mysql&gt; delimiter ;</p></blockquote><h4 id="3-MySQL-触发器查询，删除"><a href="#3-MySQL-触发器查询，删除" class="headerlink" title="3.MySQL 触发器查询，删除"></a>3.MySQL 触发器查询，删除</h4><h5 id="1-查询所有触发器"><a href="#1-查询所有触发器" class="headerlink" title="1)查询所有触发器"></a>1)查询所有触发器</h5><blockquote><p>show triggers;</p></blockquote><h5 id="2-删除触发器"><a href="#2-删除触发器" class="headerlink" title="2)删除触发器"></a>2)删除触发器</h5><blockquote><p>drop trigger xxx; (xxx 为触发器名称）</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;sqlite Trigger 触发器&lt;/p&gt;
&lt;h3 id=&quot;Trigger-触发器&quot;&gt;&lt;a href=&quot;#Trigger-触发器&quot; class=&quot;headerlink&quot; title=&quot;Trigger 触发器&quot;&gt;&lt;/a&gt;Trigger 触发器&lt;/h3&gt;&lt;p&gt;SQLite 触
      
    
    </summary>
    
    
      <category term="sqlite" scheme="https://maxiaozhou1234.github.io/categories/sqlite/"/>
    
    
      <category term="sqlite" scheme="https://maxiaozhou1234.github.io/tags/sqlite/"/>
    
  </entry>
  
  <entry>
    <title>【sqlite】unions 语法笔记</title>
    <link href="https://maxiaozhou1234.github.io/sqlite/sqlite-union/"/>
    <id>https://maxiaozhou1234.github.io/sqlite/sqlite-union/</id>
    <published>2020-02-25T03:30:03.000Z</published>
    <updated>2020-04-22T15:56:40.688Z</updated>
    
    <content type="html"><![CDATA[<p>SQLite unions 合并查询</p><blockquote><p>SQLite的 UNION 子句/运算符用于合并两个或多个 SELECT 语句的结果，不返回任何重复的行。<br>为了使用 UNION，每个 SELECT 被选择的列数必须是相同的，相同数目的列表达式，相同的数据类型，并确保它们有相同的顺序，但它们不必具有相同的长度。</p></blockquote><h3 id="SQLite-unions-合并查询"><a href="#SQLite-unions-合并查询" class="headerlink" title="SQLite unions 合并查询"></a>SQLite unions 合并查询</h3><p>将表1和表2的内容合并输出，<strong>前提是两个表中的列必须一致(列名、顺序)</strong></p><h4 id="1-内联查询"><a href="#1-内联查询" class="headerlink" title="1.内联查询"></a>1.内联查询</h4><blockquote><p>mysql&gt; select emp_id,name,dept from company inner join department on company.id=department.emp_id;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+--------+-------+-------------+</span><br><span class="line">| emp_id | name  | dept        |</span><br><span class="line">+--------+-------+-------------+</span><br><span class="line">|      1 | Paul  | IT Billing  |</span><br><span class="line">|      2 | Allen | Engineering |</span><br><span class="line">|      7 | James | Finance     |</span><br><span class="line">|      3 | Teddy | Engineering |</span><br><span class="line">|      4 | Mark  | Finance     |</span><br><span class="line">|      5 | David | Engineering |</span><br><span class="line">|      6 | Kim   | Finance     |</span><br><span class="line">+--------+-------+-------------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="2-左外连接查询"><a href="#2-左外连接查询" class="headerlink" title="2.左外连接查询"></a>2.左外连接查询</h4><blockquote><p>mysql&gt; select emp_id,name,dept from company left outer join department on company.id=department.emp_id;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+--------+-------+-------------+</span><br><span class="line">| emp_id | name  | dept        |</span><br><span class="line">+--------+-------+-------------+</span><br><span class="line">|      1 | Paul  | IT Billing  |</span><br><span class="line">|      2 | Allen | Engineering |</span><br><span class="line">|      3 | Teddy | Engineering |</span><br><span class="line">|      4 | Mark  | Finance     |</span><br><span class="line">|      5 | David | Engineering |</span><br><span class="line">|      6 | Kim   | Finance     |</span><br><span class="line">|      7 | James | Finance     |</span><br><span class="line">+--------+-------+-------------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="3-联合输出"><a href="#3-联合输出" class="headerlink" title="3.联合输出"></a>3.联合输出</h4><blockquote><p>mysql&gt; select emp_id,name,dept from company inner join department on company.id=department.emp_id union select emp_id,na<br>me,dept from company left outer join department on company.id=department.emp_id;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+--------+-------+-------------+</span><br><span class="line">| emp_id | name  | dept        |</span><br><span class="line">+--------+-------+-------------+</span><br><span class="line">|      1 | Paul  | IT Billing  |</span><br><span class="line">|      2 | Allen | Engineering |</span><br><span class="line">|      7 | James | Finance     |</span><br><span class="line">|      3 | Teddy | Engineering |</span><br><span class="line">|      4 | Mark  | Finance     |</span><br><span class="line">|      5 | David | Engineering |</span><br><span class="line">|      6 | Kim   | Finance     |</span><br><span class="line">+--------+-------+-------------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>上面这个例子结果不能很好展现合并的效果，我们更改一下第二条查询的条件，增加员工id&lt;5，如下</p><blockquote><p>mysql&gt;select emp_id,name,dept from company left outer join department on company.id=department.emp_id and company.id&lt;5;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+--------+-------+-------------+</span><br><span class="line">| emp_id | name  | dept        |</span><br><span class="line">+--------+-------+-------------+</span><br><span class="line">|      1 | Paul  | IT Billing  |</span><br><span class="line">|      2 | Allen | Engineering |</span><br><span class="line">|      3 | Teddy | Engineering |</span><br><span class="line">|      4 | Mark  | Finance     |</span><br><span class="line">|   NULL | David | NULL        |</span><br><span class="line">|   NULL | Kim   | NULL        |</span><br><span class="line">|   NULL | James | NULL        |</span><br><span class="line">+--------+-------+-------------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>这里我们看到左外连接后，id&gt;=5的员工数据被置为null，此时再联合输出：</p><blockquote><p>mysql&gt; select emp_id id,name,dept from company inner join department on company.id=department.emp_id union select emp_id<br>,name,dept from company left outer join department on company.id=department.emp_id and company.id&lt;5;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+------+-------+-------------+</span><br><span class="line">| id   | name  | dept        |</span><br><span class="line">+------+-------+-------------+</span><br><span class="line">|    1 | Paul  | IT Billing  |</span><br><span class="line">|    2 | Allen | Engineering |</span><br><span class="line">|    7 | James | Finance     |</span><br><span class="line">|    3 | Teddy | Engineering |</span><br><span class="line">|    4 | Mark  | Finance     |</span><br><span class="line">|    5 | David | Engineering |</span><br><span class="line">|    6 | Kim   | Finance     |</span><br><span class="line">| NULL | David | NULL        |</span><br><span class="line">| NULL | Kim   | NULL        |</span><br><span class="line">| NULL | James | NULL        |</span><br><span class="line">+------+-------+-------------+</span><br><span class="line">10 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>查询后可以看到，表1的查询结果都在，表2中1-4数据和表1相同合并为一，剩下三条再并表输出，总共数据为7+3 = 10条。</p><h4 id="4-union-all-合并所有"><a href="#4-union-all-合并所有" class="headerlink" title="4.union all 合并所有"></a>4.union all 合并所有</h4><p>仅使用 union 关键字，重复的项会被过滤，如果要保留两个表中的所有内容，可以使用<strong>union all</strong>合并所有数据。<br>将上面的例子修改一下：</p><blockquote><p>mysql&gt; select emp_id id,name,dept from company inner join department on company.id=department.emp_id union all select em<br>p_id,name,dept from company left outer join department on company.id=department.emp_id and company.id&lt;5;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+------+-------+-------------+</span><br><span class="line">| id   | name  | dept        |</span><br><span class="line">+------+-------+-------------+</span><br><span class="line">|    1 | Paul  | IT Billing  |</span><br><span class="line">|    2 | Allen | Engineering |</span><br><span class="line">|    7 | James | Finance     |</span><br><span class="line">|    3 | Teddy | Engineering |</span><br><span class="line">|    4 | Mark  | Finance     |</span><br><span class="line">|    5 | David | Engineering |</span><br><span class="line">|    6 | Kim   | Finance     |</span><br><span class="line">|    1 | Paul  | IT Billing  |</span><br><span class="line">|    2 | Allen | Engineering |</span><br><span class="line">|    3 | Teddy | Engineering |</span><br><span class="line">|    4 | Mark  | Finance     |</span><br><span class="line">| NULL | David | NULL        |</span><br><span class="line">| NULL | Kim   | NULL        |</span><br><span class="line">| NULL | James | NULL        |</span><br><span class="line">+------+-------+-------------+</span><br><span class="line">14 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>结果如上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SQLite unions 合并查询&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SQLite的 UNION 子句/运算符用于合并两个或多个 SELECT 语句的结果，不返回任何重复的行。&lt;br&gt;为了使用 UNION，每个 SELECT 被选择的列数必须是相同的，相同数目的列表
      
    
    </summary>
    
    
      <category term="sqlite" scheme="https://maxiaozhou1234.github.io/categories/sqlite/"/>
    
    
      <category term="sqlite" scheme="https://maxiaozhou1234.github.io/tags/sqlite/"/>
    
  </entry>
  
  <entry>
    <title>【sqlite】join 语法笔记</title>
    <link href="https://maxiaozhou1234.github.io/sqlite/sqlite-join/"/>
    <id>https://maxiaozhou1234.github.io/sqlite/sqlite-join/</id>
    <published>2020-02-25T02:01:00.000Z</published>
    <updated>2020-04-22T15:56:40.687Z</updated>
    
    <content type="html"><![CDATA[<p>SQLite 数据库 join 语法笔记</p><h3 id="SQLite-关键字-join"><a href="#SQLite-关键字-join" class="headerlink" title="SQLite 关键字 join"></a>SQLite 关键字 join</h3><h4 id="1-cross-join-交叉连接"><a href="#1-cross-join-交叉连接" class="headerlink" title="1.cross join 交叉连接"></a>1.cross join 交叉连接</h4><p>把第一个表的每一行和第二个表的每一行进行匹配。如表1有m行，表2有n行，交叉连接之后有 m*n 行。</p><p><strong>select * from company;</strong></p><p><img src="https://i.loli.net/2020/02/24/eFaoVbMcN9fzvnU.png" alt="1.png"></p><p><strong>select * from department;</strong></p><p><img src="https://i.loli.net/2020/02/24/NLHugBocmZ5IdFC.png" alt="2.png"></p><p><strong>select emp_id,name,dept from company cross join department;</strong></p><p><img src="https://i.loli.net/2020/02/24/YzhkEsmfAxjnSpv.png" alt="3.png"></p><h4 id="2-inner-join-内联"><a href="#2-inner-join-内联" class="headerlink" title="2.inner join 内联"></a>2.inner join 内联</h4><p>根据连接条件结合两个表的列值创建一个新的结果表。<br>内连接语法：</p><ol><li><blockquote><p>SELECT … FROM table1 [INNER] JOIN table2 ON conditional_expression …</p></blockquote></li><li><p>为了避免冗余，并保持较短的措辞，可以使用 USING 表达式声明内连接（INNER JOIN）条件。这个表达式指定一个或多个列的列表：<strong>注：如果两张表的关联字段名相同，才可以使用USING子句</strong> </p><blockquote><p>SELECT … FROM table1 JOIN table2 USING ( column1 ,… ) …</p></blockquote></li><li><p>自然连接（NATURAL JOIN）类似于 JOIN…USING，只是它会自动测试存在两个表中的每一列的值之间相等值：</p><blockquote><p>SELECT … FROM table1 NATURAL JOIN table2…</p></blockquote></li></ol><p>示例：<br><strong>select emp_id,name,dept from company inner join department on company.id=department.emp_id;</strong></p><p><img src="https://i.loli.net/2020/02/24/bRU9NXdnQfkBwlr.png" alt="4.png"></p><h4 id="3-outer-join-外连接"><a href="#3-outer-join-外连接" class="headerlink" title="3.outer join 外连接"></a>3.outer join 外连接</h4><p>外连接（OUTER JOIN）是内连接（INNER JOIN）的扩展。虽然 SQL 标准定义了三种类型的外连接：LEFT、RIGHT、FULL，<strong>但 SQLite 只支持 左外连接（LEFT OUTER JOIN）</strong>。</p><ol><li>左连接 left outer join/left join<br>关联两张或多张表中，根据条件显示匹配的数据。依附于左表进行扩展，扩展后表中内容如果右表没有匹配数据，则用 null 显示。</li><li>右连接 right outer join/right join<br>关联两张或多张表中，根据条件显示匹配的数据。依附于右表进行扩展，扩展后表中内容如果左表没有匹配数据，则用 null 显示。</li><li>全连接 full outer join/right join<br>全外连接就是关联的两张或多张表中，根据关联条件，显示所有匹配和不匹配的记录。<br>左表中有的记录，但是右表中没有匹配上的，以空(null)显示。右表中有的记录，但是左表中没有匹配上的，也以空(null)显示。<br>FULL OUTER JOIN也可以简写成FULL JOIN，效果是一样的。</li></ol><p>左外连接语法：</p><ol><li><blockquote><p>SELECT … FROM table1 LEFT OUTER JOIN table2 ON [conditional_expression 条件] …</p></blockquote></li><li><p>为了避免冗余，可以使用 <strong>using</strong> 声明条件 </p><blockquote><p>SELECT … FROM table1 LEFT OUTER JOIN table2 USING ( column1 ,… ) …</p></blockquote></li></ol><p>示例：<br><strong>select emp_id,name,dept from company left outer join department on company.id=department.emp_id;</strong></p><p><img src="https://i.loli.net/2020/02/24/QgiYNUvdqa1JRwm.png" alt="5.png"></p><h4 id="4-自连接，扩展"><a href="#4-自连接，扩展" class="headerlink" title="4.自连接，扩展"></a>4.自连接，扩展</h4><p>只有一张表，通过把表取别名，当作两张表使用，自己和自己关联。</p><p>示例：查询经理的名称，通过员工id和经理id相同自连接查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">create table employ (id int,name char(20),salary real check(salary &gt;0),manager_id int);</span><br><span class="line"></span><br><span class="line">insert into employ values (1,&#39;aa&#39;,2000,3);</span><br><span class="line">insert into employ values (2,&#39;bb&#39;,1000,3);</span><br><span class="line">insert into employ values (3,&#39;cc&#39;,2500,4);</span><br><span class="line">insert into employ values (4,&#39;dd&#39;,6000,100);</span><br><span class="line">insert into employ values (100,&#39;ee&#39;,6000,0);</span><br><span class="line"></span><br><span class="line">默认使用 inner join，同样也可以使用left join</span><br><span class="line">select e.name,e.salary,e2.name manager from employ e ，employ e2 on e.manager_id &#x3D; e2.id;</span><br><span class="line"></span><br><span class="line">使用条件 where</span><br><span class="line">select e.name,e.salary,e2.name manager from employ e , employ e2 where e.manager_id &#x3D; e2.id;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/24/7ut5ZO6Vsm8aNiX.png" alt="6.png"></p><hr><p>图片存储记录：<br><a href="https://i.loli.net/2020/02/24/eFaoVbMcN9fzvnU.png" target="_blank" rel="noopener">1.png</a><br><a href="https://i.loli.net/2020/02/24/NLHugBocmZ5IdFC.png" target="_blank" rel="noopener">2.png</a><br><a href="https://i.loli.net/2020/02/24/7ut5ZO6Vsm8aNiX.png" target="_blank" rel="noopener">6.png</a><br><a href="https://i.loli.net/2020/02/24/bRU9NXdnQfkBwlr.png" target="_blank" rel="noopener">4.png</a><br><a href="https://i.loli.net/2020/02/24/QgiYNUvdqa1JRwm.png" target="_blank" rel="noopener">5.png</a><br><a href="https://i.loli.net/2020/02/24/YzhkEsmfAxjnSpv.png" target="_blank" rel="noopener">3.png</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SQLite 数据库 join 语法笔记&lt;/p&gt;
&lt;h3 id=&quot;SQLite-关键字-join&quot;&gt;&lt;a href=&quot;#SQLite-关键字-join&quot; class=&quot;headerlink&quot; title=&quot;SQLite 关键字 join&quot;&gt;&lt;/a&gt;SQLite 关键字 jo
      
    
    </summary>
    
    
      <category term="sqlite" scheme="https://maxiaozhou1234.github.io/categories/sqlite/"/>
    
    
      <category term="sqlite" scheme="https://maxiaozhou1234.github.io/tags/sqlite/"/>
    
  </entry>
  
  <entry>
    <title>【MySQL】操作命令</title>
    <link href="https://maxiaozhou1234.github.io/sqlite/mysql-cmd/"/>
    <id>https://maxiaozhou1234.github.io/sqlite/mysql-cmd/</id>
    <published>2020-02-25T02:00:00.000Z</published>
    <updated>2020-04-22T15:56:40.686Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL 基本操作命令</p><h3 id="MySQL-基本操作命令"><a href="#MySQL-基本操作命令" class="headerlink" title="MySQL 基本操作命令"></a>MySQL 基本操作命令</h3><ol><li>查看所有数据库<br>show databases;</li><li>使用数据库<br>use xxx;</li><li>创建数据库<br>create database xxx charset=utf8;//创建xx数据库，并指定编码</li><li>查看创建数据库时的语法命令<br>show create database xxx;</li><li>查看数据库中所有的表<br>show tables;</li><li>删除数据库<br>drop database xxx;</li><li>查看所有触发器<br>show triggers;</li><li>查看指定表触发器（使用 \G 切换视图为纵向输出）<br>select * from information_schema.triggers where EVENT_OBJECT_TABLE=’table_name’;</li><li>删除触发器<br>drop trigger trigger_name;</li><li>查看表结构<br>desc table;<br>describe table;</li><li>创建视图<br>create view view_name as select column1[…] from table where [condition];</li><li>删除视图<br>drop view name; </li></ol><h3 id="MySQL-5-5版本注意"><a href="#MySQL-5-5版本注意" class="headerlink" title="MySQL 5.5版本注意"></a>MySQL 5.5版本注意</h3><ol><li>没有 datatime,如需要使用时间戳，用<strong>timestmap</strong>代替</li><li>默认使用分号<strong>；</strong>结束判断，如果需要多行输入，将delimiter ; 更改为delimiter //，按<strong>“//”</strong>为结束判断 </li><li>没有 datetime ，时间戳使用 timestamp</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MySQL 基本操作命令&lt;/p&gt;
&lt;h3 id=&quot;MySQL-基本操作命令&quot;&gt;&lt;a href=&quot;#MySQL-基本操作命令&quot; class=&quot;headerlink&quot; title=&quot;MySQL 基本操作命令&quot;&gt;&lt;/a&gt;MySQL 基本操作命令&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;查看所有
      
    
    </summary>
    
    
      <category term="sqlite" scheme="https://maxiaozhou1234.github.io/categories/sqlite/"/>
    
    
      <category term="MySQL" scheme="https://maxiaozhou1234.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>【java】NIO 小结</title>
    <link href="https://maxiaozhou1234.github.io/java/java-nio/"/>
    <id>https://maxiaozhou1234.github.io/java/java-nio/</id>
    <published>2020-02-11T09:15:45.000Z</published>
    <updated>2020-04-22T15:56:40.686Z</updated>
    
    <content type="html"><![CDATA[<p>java NIO 学习后的小结</p><h3 id="1-NIO-总述"><a href="#1-NIO-总述" class="headerlink" title="1. NIO 总述"></a>1. NIO 总述</h3><p>nio 为 Non-blocking io，即不阻塞io操作，java在为并发提供的 io 操作类，主要有三个核心类，分别为：</p><ul><li>Channel 操作数据通道</li><li>Buffer 缓冲数据区域</li><li>Selector 用于管理 channel</li></ul><h3 id="2-BIO-与-NIO-的主要区别"><a href="#2-BIO-与-NIO-的主要区别" class="headerlink" title="2. BIO 与 NIO 的主要区别"></a>2. BIO 与 NIO 的主要区别</h3><h4 id="2-1-面向操作"><a href="#2-1-面向操作" class="headerlink" title="2.1 面向操作"></a>2.1 面向操作</h4><p>BIO 是面向流操作，NIO 是面向缓冲操作。BIO 每次从流读写一个或多个字节，直至所有字节被读写完成，该过程数据没有被缓存到其它地方，它不能前后移动流中的数据。</p><p>NIO 将数据先缓冲到稍后处理的区域，需要时可以在缓冲区前后移动，具备处理过程中的灵活性。</p><h4 id="2-2-阻塞与非阻塞"><a href="#2-2-阻塞与非阻塞" class="headerlink" title="2.2 阻塞与非阻塞"></a>2.2 阻塞与非阻塞</h4><p>Java IO 流失阻塞的，意味着，当线程调用 read（）或 write（）时，该线程被阻塞，直到数据完全读取或者写入，期间线程无法进行其它处理。</p><p>NIO 的非阻塞模式，可以让线程请求写入一些数据到某通道，但不需要等到操作完成，这个现场同时可以去做其他事情。线程通常将非阻塞IO空闲时间用于其他通道上执行IO操作，所以一个线程可以管理多个输入、输出通道。</p><h4 id="2-3-选择器"><a href="#2-3-选择器" class="headerlink" title="2.3 选择器"></a>2.3 选择器</h4><p>NIO 的选择器允许一个单独线程监视多个输入通道，可以注册多个通道使用一个选择器，然后监控可以处理的输入通道进行操作。</p><h3 id="3-NIO-中的-channel"><a href="#3-NIO-中的-channel" class="headerlink" title="3. NIO 中的 channel"></a>3. NIO 中的 channel</h3><h4 id="3-1-FileChannel"><a href="#3-1-FileChannel" class="headerlink" title="3.1 FileChannel"></a>3.1 FileChannel</h4><p>FileChannel 可以通过 <code>RandomAccessFile.getChannel()</code> 或 <code>InputStream,OutputStream .getChannel()</code> 获取，示例代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">channelCopy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Instant begin = Instant.now();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        RandomAccessFile source = <span class="keyword">new</span> RandomAccessFile(<span class="string">"./res/threeWithoutPunctuation"</span>, <span class="string">"r"</span>);</span><br><span class="line">        RandomAccessFile target = <span class="keyword">new</span> RandomAccessFile(<span class="string">"./res/copyFileNio"</span>, <span class="string">"rw"</span>);</span><br><span class="line"></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>*<span class="number">8</span>);</span><br><span class="line">        FileChannel sourceChannel = source.getChannel();</span><br><span class="line">        FileChannel targetChannel = target.getChannel();</span><br><span class="line">        <span class="keyword">while</span> (sourceChannel.read(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                targetChannel.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        sourceChannel.close();</span><br><span class="line">        targetChannel.close();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"[channelCopy] Done &gt;&gt; "</span> + (Duration.between(begin, Instant.now()).toMillis()) + <span class="string">" ms"</span>);</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">测试在小文件复制速度可能不如流操作，但在大文件拷贝速度比流复制快，测试拷贝<span class="number">1.03</span>G文件，channel 耗时 <span class="number">1.08</span>s，而 stream 需要 <span class="number">11.31</span>s。</span><br><span class="line"></span><br><span class="line">#### 3.2 DatagramChannel</span><br><span class="line">DatagramChannel 广播包的操作，区别不大，示例代码如下：</span><br><span class="line"></span><br><span class="line">服务端</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">private</span> SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>, Locale.getDefault());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        DatagramChannel datagramChannel = DatagramChannel.open();</span><br><span class="line">        datagramChannel.configureBlocking(<span class="keyword">true</span>);</span><br><span class="line">        datagramChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8000</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"启动服务端"</span>);</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        SocketAddress socketAddress;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//超过buffer大小部分将被丢弃</span></span><br><span class="line">            <span class="keyword">if</span> ((socketAddress = datagramChannel.receive(buffer)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                buffer.flip();</span><br><span class="line">                System.out.println(Charset.forName(<span class="string">"UTF-8"</span>).decode(buffer));</span><br><span class="line">                buffer.clear();</span><br><span class="line">                datagramChannel.send(Charset.forName(<span class="string">"UTF-8"</span>).encode(<span class="string">"服务端已收到["</span> + format.format(<span class="keyword">new</span> Date())), socketAddress);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DatagramNioClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        DatagramChannel datagramChannel = DatagramChannel.open();</span><br><span class="line">        datagramChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8001</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (datagramChannel.receive(buffer) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        System.out.print(<span class="string">"收到消息："</span>);</span><br><span class="line">                        System.out.println(Charset.forName(<span class="string">"UTF-8"</span>).decode(buffer));</span><br><span class="line">                        buffer.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"启动客户端"</span>);</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">            send(datagramChannel, scanner.nextLine());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(DatagramChannel datagramChannel, String msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        datagramChannel.send(Charset.forName(<span class="string">"UTF-8"</span>).encode(msg), <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8000</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需注意，如果接收数据超过设定容器的大小，超过部分会丢弃。比如对方发送了128K数据，而我容器只有48K大小，那么我只接收到48K数据，而剩余部分直接被丢弃。</p><p>对于数据的读取可以传入 ByteBuffer[] 数据，将按照顺序进行填充，对于一些固定大小数据头的数据包，使用非常方便，缺点容量一旦确定不可修改，弹性差，示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    DatagramChannel datagramChannel = DatagramChannel.open();</span><br><span class="line">    datagramChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>,<span class="number">8001</span>));</span><br><span class="line">    ByteBuffer headBuffer = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">    ByteBuffer bodyBuffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">    datagramChannel.read(<span class="keyword">new</span> ByteBuffer[]&#123;headBuffer,bodyBuffer&#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>connect</code> 并非真正的建立连接，而是锁定 channel 通道，让该通道只能通过特定的地址收发数据。 </p><h4 id="3-3-SocketChannel-ServerSocketChannel"><a href="#3-3-SocketChannel-ServerSocketChannel" class="headerlink" title="3.3 SocketChannel,ServerSocketChannel"></a>3.3 SocketChannel,ServerSocketChannel</h4><p>这两个 SocketChannel 是 socket 的并发版本，通常我们通过 <code>ServerSocket</code> 来监听端口，一旦有客户端连接，就创建线程进行通信，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8000</span>);</span><br><span class="line">    Socket socket;</span><br><span class="line">    <span class="keyword">while</span> ((socket = serverSocket.accept()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> Socket ss = socket;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                InputStream in = ss.getInputStream();</span><br><span class="line">                OutputStream out = ss.getOutputStream();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一次连接都需要创建线程进行通信，所以服务端线程数与客户端数量呈1:1关系，线程的创建需要消耗服务器资源，而服务器资源有限，在并发高且传输数据小的环境，这种方式无法满足要求。</p><p>SocketChannel 能够很好的解决高并发下的资源问题，通过 Selector 注册后，在非阻塞模式下仅使用单线程可以管理多个通道并实现数据传输，服务端示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立服务端监听，设置为非阻塞模式</span></span><br><span class="line">    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">    serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8000</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//将 channel 注册到 selector</span></span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line">    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">//检查是否有可处理通道</span></span><br><span class="line">        <span class="keyword">int</span> num = selector.select();</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">continue</span>;<span class="comment">//jdk 中空转有一定几率造成 cpu 100%</span></span><br><span class="line"></span><br><span class="line">        Set&lt;SelectionKey&gt; set = selector.selectedKeys();</span><br><span class="line">        Iterator&lt;SelectionKey&gt; it = set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            SelectionKey key = it.next();</span><br><span class="line"></span><br><span class="line">            it.remove();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (key.isAcceptable()) &#123;<span class="comment">//把通道注册为可读</span></span><br><span class="line"></span><br><span class="line">                ServerSocketChannel channel = (ServerSocketChannel) key.channel();</span><br><span class="line"></span><br><span class="line">                SocketChannel acceptChannel = channel.accept();</span><br><span class="line">                acceptChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                acceptChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;<span class="comment">//处理已连接 channel 数据</span></span><br><span class="line">                SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                <span class="keyword">if</span>(channel.read(buffer)!=-<span class="number">1</span>)&#123;</span><br><span class="line">buffer.flip();</span><br><span class="line">                System.out.println(Charset.forName(<span class="string">"UTF-8"</span>).decode(buffer));</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">channel.write(Charset.forName(<span class="string">"UTF-8"</span>).encode(<span class="string">"回复"</span>));</span><br><span class="line">&#125;</span><br><span class="line">                channel.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出，SocketChannel 在并发量大处理的优越性。</p><p>如果是需要管理成千上万个连接，并且这些连接每次只是发送少量的数据，如聊天服务器这类需求，实现NIO服务器可能是一个优势，但如果是少量连接使用，一次发送大量数据，还是典型的IO服务器实现更符合要求。</p><p>当然 SocketChannel 还是存在缺点，比如注释中写到可能出现cpu占用100%的bug（说已修复但仍有小概率出现），api使用比较复杂，但对于小型的服务处理，NIO服务器仍然是一个高效可用的实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;java NIO 学习后的小结&lt;/p&gt;
&lt;h3 id=&quot;1-NIO-总述&quot;&gt;&lt;a href=&quot;#1-NIO-总述&quot; class=&quot;headerlink&quot; title=&quot;1. NIO 总述&quot;&gt;&lt;/a&gt;1. NIO 总述&lt;/h3&gt;&lt;p&gt;nio 为 Non-blocking io
      
    
    </summary>
    
    
      <category term="java" scheme="https://maxiaozhou1234.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://maxiaozhou1234.github.io/tags/java/"/>
    
      <category term="nio" scheme="https://maxiaozhou1234.github.io/tags/nio/"/>
    
  </entry>
  
  <entry>
    <title>【其他】gittalk 配置问题</title>
    <link href="https://maxiaozhou1234.github.io/default/gittalk/"/>
    <id>https://maxiaozhou1234.github.io/default/gittalk/</id>
    <published>2020-02-11T06:58:05.000Z</published>
    <updated>2020-04-22T15:56:40.686Z</updated>
    
    <content type="html"><![CDATA[<p>使用 gittalk 为 Hexo 添加评论功能，遇到问题及解决方法</p><h3 id="1-申请及配置"><a href="#1-申请及配置" class="headerlink" title="1.申请及配置"></a>1.申请及配置</h3><h4 id="1-1-注册-gittalk"><a href="#1-1-注册-gittalk" class="headerlink" title="1.1 注册 gittalk"></a>1.1 注册 gittalk</h4><p>可通过 <a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">Register a new OAuth application</a> 进行注册。如果已经注册过，可以在 github 首页点击头像下拉，“Settings – Developer settings – OAuth Apps” 查看你的app，选择你注册的 app 进行再次编辑。</p><h4 id="1-2-配置填写"><a href="#1-2-配置填写" class="headerlink" title="1.2 配置填写"></a>1.2 配置填写</h4><ul><li><p>Application name： 应用名称，随意</p></li><li><p>Homepage URL： 网站URL，对应自己博客地址</p></li><li><p>Application description ：描述，随意</p></li><li><p>Authorization callback URL：# 网站URL，博客地址就好</p></li><li><p>点击注册，页面会出现其中Client ID和Client Secret在后面的配置中需要用到</p></li></ul><p>如我的 gittalk 填写如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Application name： CommentApp</span><br><span class="line">Homepage URL： https:&#x2F;&#x2F;maxiaozhou1234.github.io # 网站URL，对应自己博客地址</span><br><span class="line">Application description ：repo # 描述，随意</span><br><span class="line">Authorization callback URL：https:&#x2F;&#x2F;maxiaozhou1234.github.io # 网站URL，博客地址就好，如果有独立域名，可填写你的域名用于跳转</span><br></pre></td></tr></table></figure><h4 id="1-3-在主题的-config-yml-进行配置"><a href="#1-3-在主题的-config-yml-进行配置" class="headerlink" title="1.3 在主题的 _config.yml 进行配置"></a>1.3 在主题的 _config.yml 进行配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#Cmments</span><br><span class="line">comment:</span><br><span class="line">  gitalk:</span><br><span class="line">    enable: true ## 开启gitalk</span><br><span class="line">    owner: ## GitHub的用户名</span><br><span class="line">    repo: ## 此评论存放的GitHub仓库</span><br><span class="line">    client_id: ## 复制刚才生成的clientID，例如. 75752dafe7907a897619</span><br><span class="line">    client_secret: ## 复制刚才生成的clientSecret，例如. ec2fb9054972c891289640354993b662f4cccc50</span><br><span class="line">    admin: ## Github的用户名</span><br><span class="line">id: location.pathname</span><br><span class="line">    language: zh-CN ## Language</span><br><span class="line">    pagerDirection: last # Comment sorting direction, available values are last and first.</span><br></pre></td></tr></table></figure><p>主题的配置，可以参考<a href="https://chaooo.github.io/article/20161229.html" target="_blank" rel="noopener">【Hexo博客折腾】BlueLake博客主题的详细配置</a></p><h3 id="2-搭建过程遇到的问题"><a href="#2-搭建过程遇到的问题" class="headerlink" title="2. 搭建过程遇到的问题"></a>2. 搭建过程遇到的问题</h3><h4 id="2-1-评论区显示-Error-Not-Found"><a href="#2-1-评论区显示-Error-Not-Found" class="headerlink" title="2.1 评论区显示 Error: Not Found"></a>2.1 评论区显示 Error: Not Found</h4><p>遇到 Error: Not Found，这个问题是主题 _config.yml 中 gittalk 配置中 repo 填写错误，修改为你的博客主页即可，如我的博客配置如下：</p><blockquote><p>repo： maxiaozhou1234.github.io</p></blockquote><h4 id="2-2-博客评论登录跳转到首页问题"><a href="#2-2-博客评论登录跳转到首页问题" class="headerlink" title="2.2 博客评论登录跳转到首页问题"></a>2.2 博客评论登录跳转到首页问题</h4><p>申请配置是填写的<code>Homepage URL</code>,<code>Authorization callback URL</code> 不正确导致，第一个填博客首页，第二个是授权回调页面，因为我没有使用独立的域名，所以两个都填博客首页，如下</p><blockquote><p>Homepage URL：<a href="https://maxiaozhou1234.github.io">https://maxiaozhou1234.github.io</a><br>Authorization callback URL：<a href="https://maxiaozhou1234.github.io">https://maxiaozhou1234.github.io</a></p></blockquote><p>如果你是有自己独立的域名，将 <code>Authorization callback URL</code> 填写为你的域名，前提是你已完成了域名的绑定，还有注意 https 和 http 区别，需完全一致。</p><p>参考文章：<a href="https://blog.csdn.net/w47_csdn/article/details/88858343" target="_blank" rel="noopener">解决配置gitalk插件后初始化登录时跳转回首页</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用 gittalk 为 Hexo 添加评论功能，遇到问题及解决方法&lt;/p&gt;
&lt;h3 id=&quot;1-申请及配置&quot;&gt;&lt;a href=&quot;#1-申请及配置&quot; class=&quot;headerlink&quot; title=&quot;1.申请及配置&quot;&gt;&lt;/a&gt;1.申请及配置&lt;/h3&gt;&lt;h4 id=&quot;1-1
      
    
    </summary>
    
    
      <category term="default" scheme="https://maxiaozhou1234.github.io/categories/default/"/>
    
    
      <category term="gittalk" scheme="https://maxiaozhou1234.github.io/tags/gittalk/"/>
    
      <category term="hexo" scheme="https://maxiaozhou1234.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
