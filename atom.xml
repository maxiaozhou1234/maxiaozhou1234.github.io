<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xiaozhou Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://maxiaozhou1234.github.io/"/>
  <updated>2020-04-22T16:11:58.281Z</updated>
  <id>https://maxiaozhou1234.github.io/</id>
  
  <author>
    <name>ma xiaozhou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Android】PagerAdapter不刷新问题分析</title>
    <link href="https://maxiaozhou1234.github.io/android/pager-adapter/"/>
    <id>https://maxiaozhou1234.github.io/android/pager-adapter/</id>
    <published>2020-04-22T14:50:10.000Z</published>
    <updated>2020-04-22T16:11:58.281Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用-PagerAdapter-notifyDataSetChange-不刷新问题分析"><a href="#使用-PagerAdapter-notifyDataSetChange-不刷新问题分析" class="headerlink" title="使用 PagerAdapter notifyDataSetChange 不刷新问题分析"></a>使用 PagerAdapter notifyDataSetChange 不刷新问题分析</h2><p>无论是普通的 ViewPager 视图，还是用 Fragment，当我们刷新数据后调用 notifyDataSetChange 后，往往会发现当前界面并没有预想的触发刷新，根本原因在于 ViewPager 的缓存机制判定数据未发生变化，从而不触发刷新，及时数据确实发生了改变。</p><h3 id="1-未触发刷新效果及分析"><a href="#1-未触发刷新效果及分析" class="headerlink" title="1. 未触发刷新效果及分析"></a>1. 未触发刷新效果及分析</h3><p>假设当前 page 是第一页，第一个数据发生变更，此时调用 notifyDataSetChange 后页面并没有变化，原因在于当前页面没有触发强制刷新，仅仅是从缓存中取数据而已。</p><h4 id="1-1-不刷新模拟效果"><a href="#1-1-不刷新模拟效果" class="headerlink" title="1.1 不刷新模拟效果"></a>1.1 不刷新模拟效果</h4><p>ViewPager 默认缓存数是1，即当前页+缓存，总共2，从效果图也可以看出更新数据后，当前页和滑动一页并不会销毁改页，在两页之后回到第一页，之前的页才被销毁，重新创建。</p><p>此页面有三个 view 在 ViewPager 中，当点击按钮会更新第一个 view 中的文字，在没有重写 getItemPosition 下，效果如下所示</p><p><img src="https://i.loli.net/2020/04/22/OgJVmaLwPqNjShb.gif" alt="vp_2.gif"></p><h4 id="1-2-不刷新源码分析"><a href="#1-2-不刷新源码分析" class="headerlink" title="1.2 不刷新源码分析"></a>1.2 不刷新源码分析</h4><p>当然，我们可以从 ViewPager 中看到，当我们调用 notifyDataSetChange 后会回调 VP 的 <code>void dataSetChanged()</code>，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">void dataSetChanged() &#123;</span><br><span class="line">&#x2F;&#x2F; This method only gets called if our observer is attached, so mAdapter is non-null.</span><br><span class="line"></span><br><span class="line">    final int adapterCount &#x3D; mAdapter.getCount();</span><br><span class="line">    mExpectedAdapterCount &#x3D; adapterCount;</span><br><span class="line">    boolean needPopulate &#x3D; mItems.size() &lt; mOffscreenPageLimit * 2 + 1</span><br><span class="line">            &amp;&amp; mItems.size() &lt; adapterCount;</span><br><span class="line">    int newCurrItem &#x3D; mCurItem;</span><br><span class="line"></span><br><span class="line">    boolean isUpdating &#x3D; false;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; mItems.size(); i++) &#123;</span><br><span class="line">        final ItemInfo ii &#x3D; mItems.get(i);</span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;核心方法&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">        final int newPos &#x3D; mAdapter.getItemPosition(ii.object);</span><br><span class="line"></span><br><span class="line">        if (newPos &#x3D;&#x3D; PagerAdapter.POSITION_UNCHANGED) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (newPos &#x3D;&#x3D; PagerAdapter.POSITION_NONE) &#123;</span><br><span class="line">            mItems.remove(i);</span><br><span class="line">            i--;</span><br><span class="line"></span><br><span class="line">            if (!isUpdating) &#123;</span><br><span class="line">                mAdapter.startUpdate(this);</span><br><span class="line">                isUpdating &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mAdapter.destroyItem(this, ii.position, ii.object);</span><br><span class="line">            needPopulate &#x3D; true;</span><br><span class="line"></span><br><span class="line">            if (mCurItem &#x3D;&#x3D; ii.position) &#123;</span><br><span class="line">                &#x2F;&#x2F; Keep the current item in the valid range</span><br><span class="line">                newCurrItem &#x3D; Math.max(0, Math.min(mCurItem, adapterCount - 1));</span><br><span class="line">                needPopulate &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">&#x2F;&#x2F;...省略一大堆</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;...省略一大堆</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会遍历所有缓存，通过 <code>mAdapter.getItemPosition(obj)</code> 判断是否需要销毁重建，该方法默认值 <code>POSITION_UNCHANGED</code> 为-1，即默认数据没有变化。所以我们只需要重写这个方法，确定当前位置的数据是否应该销毁，当然有很多 demo 都是直接建议销毁，即返回 POSITION_NONE。本身 ViewPager 设计并不是为频繁变化的数据，所以数据变化频繁或者为了性能更好，尽可能使用 RecyclerView + PagerSnapHelper 替换 VP。</p><h4 id="1-3-重写-adapter-中方法实现刷新"><a href="#1-3-重写-adapter-中方法实现刷新" class="headerlink" title="1.3 重写 adapter 中方法实现刷新"></a>1.3 重写 adapter 中方法实现刷新</h4><p>好，为了继续使用 VP 来更新，应该动态的判断这个 <code>getItemPosition</code>，本身 VP 性能一般，一刀切不适合这种场景，所以我们通过 <code>setTag</code> 来解决这个数据关联问题，如下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;HashMap&lt;String, String&gt;&gt; data &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">class Adapter extends PagerAdapter &#123;</span><br><span class="line">&#x2F;&#x2F;...省略其他方法</span><br><span class="line">@NonNull</span><br><span class="line">    @Override</span><br><span class="line">    public Object instantiateItem(@NonNull ViewGroup container, int position) &#123;</span><br><span class="line">        TextView view &#x3D; (TextView) LayoutInflater.from(ViewPagerActivity.this).inflate(R.layout.layout_simple_text, container, false);</span><br><span class="line">        String text &#x3D; data.get(position).get(&quot;name&quot;);</span><br><span class="line">        view.setText(text);</span><br><span class="line">        view.setTag(-1, position);</span><br><span class="line">        view.setTag(-2, text);</span><br><span class="line">        container.addView(view);</span><br><span class="line">        return view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getItemPosition(@NonNull Object object) &#123;</span><br><span class="line">        if (getCount() &#x3D;&#x3D; 0)</span><br><span class="line">            return POSITION_UNCHANGED;</span><br><span class="line">        View view &#x3D; (View) object;</span><br><span class="line">        int pos &#x3D; (int) view.getTag(-1);</span><br><span class="line">        String msg &#x3D; (String) view.getTag(-2);</span><br><span class="line">        if (pos &gt;&#x3D; getCount()) &#123;</span><br><span class="line">            return POSITION_NONE;</span><br><span class="line">        &#125;</span><br><span class="line">        return msg.equals(data.get(pos).get(&quot;name&quot;)) ? POSITION_UNCHANGED : POSITION_NONE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更改之后效果图：</p><p>在判断之后，数据修改之后可以及时反馈到界面上，代价是需要数据源标记原始数据位置，但仅仅是一个4位的int</p><p><img src="https://i.loli.net/2020/04/22/OgJVmaLwPqNjShb.gif" alt="vp_2.gif"></p><h3 id="2-为什么还要使用-PagerAdapter？"><a href="#2-为什么还要使用-PagerAdapter？" class="headerlink" title="2. 为什么还要使用 PagerAdapter？"></a>2. 为什么还要使用 PagerAdapter？</h3><p>ViewPager 在普通的 View 页面，在今天，使用空间其实很小了，但在 Fragment 组合页面，配合 FragmentPagerAdapter，不得不说非常方便，如果在存在需要动态增减 Fragment，使用 <code>getItemPosition（obj）</code> 来减少创建销毁还是比较合适，当然使用场景是固定几个 fragment （2-3个）配合<code>setOffscreenPageLimit</code>缓存可以一次创建足够，如果有一堆页面（超过设置的缓存数量），这个创建销毁过程的消耗还是客观存在，不容小觑。</p><h3 id="3-FragmentPagerAdapter-改造，更适合-Fragment-增减"><a href="#3-FragmentPagerAdapter-改造，更适合-Fragment-增减" class="headerlink" title="3. FragmentPagerAdapter 改造，更适合 Fragment 增减"></a>3. FragmentPagerAdapter 改造，更适合 Fragment 增减</h3><h4 id="3-1-Fragment-创建"><a href="#3-1-Fragment-创建" class="headerlink" title="3.1 Fragment 创建"></a>3.1 Fragment 创建</h4><p>使用 <code>FragmentPagerAdapter</code> 有页面替换需要，除了重写 <code>getItemPosition()</code> 还需要重写 <code>getItemId(position)</code>。为什么？因为 <code>fragment</code> 存在于 <code>FragmentManager</code> 中，通过 <code>mFragmentManager.findFragmentByTag(name)</code> 来找到之前的 fragment，也可以理解为** fragment 的缓存**，具体源码代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiateItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCurTransaction == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mCurTransaction = mFragmentManager.beginTransaction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> itemId = getItemId(position);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do we already have this fragment?</span></span><br><span class="line">    String name = makeFragmentName(container.getId(), itemId);</span><br><span class="line">    Fragment fragment = mFragmentManager.findFragmentByTag(name);</span><br><span class="line">    <span class="keyword">if</span> (fragment != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Attaching item #"</span> + itemId + <span class="string">": f="</span> + fragment);</span><br><span class="line">        mCurTransaction.attach(fragment);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fragment = getItem(position);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Adding item #"</span> + itemId + <span class="string">": f="</span> + fragment);</span><br><span class="line">        mCurTransaction.add(container.getId(), fragment,</span><br><span class="line">                makeFragmentName(container.getId(), itemId));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fragment != mCurrentPrimaryItem) &#123;</span><br><span class="line">        fragment.setMenuVisibility(<span class="keyword">false</span>);</span><br><span class="line">        fragment.setUserVisibleHint(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fragment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有重写该方法，那么，在增减数据后，即使 <code>getItemPosition</code> 判定数据变化，再通过 <code>makeFragmentName(container.getId(), itemId)</code> （itemId 默认是position）获取的 tag 还是不变，那么重新拿到的 fragment 和原来位置的 fragment 一样，，所以必须通过重写 <code>getItemId</code> 来修改 tag，使这数据源中的 fragment 和这个 tag 形成唯一个关联关系，一般唯一性用hashCode就足够了。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Fragment&gt; data = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageAdapter</span> <span class="keyword">extends</span> <span class="title">FragmentPagerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    PageAdapter(FragmentManager fm) &#123;</span><br><span class="line">        <span class="keyword">super</span>(fm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fragment <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        SimpleFragment fragment = (SimpleFragment) data.get(position);</span><br><span class="line">        fragment.setPosition(position);</span><br><span class="line">        <span class="keyword">return</span> fragment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getItemId</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.get(position).hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemPosition</span><span class="params">(@NonNull Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getCount() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> POSITION_UNCHANGED;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> position = ((SimpleFragment) object).getPosition();</span><br><span class="line">        <span class="keyword">if</span> (position &gt;= getCount()) &#123;</span><br><span class="line">            <span class="keyword">return</span> POSITION_NONE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data.get(position).hashCode() == object.hashCode() ? POSITION_UNCHANGED : POSITION_NONE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong> SimpleFragment 只是继承 Fragment 增加一个 position 参数及相应方法。</p><h4 id="3-2-适配器修改前后效果图示"><a href="#3-2-适配器修改前后效果图示" class="headerlink" title="3.2 适配器修改前后效果图示"></a>3.2 适配器修改前后效果图示</h4><p>效果图：操作中的删除为 data.remove(1);//删除第二个数据</p><p>1.仅修改 getItemPosition</p><p><img src="https://i.loli.net/2020/04/22/bAvY6T1UgLHkFEh.gif" alt="vp_3.gif"></p><p>2.修改 getItemPosition 和 getItemId</p><p><img src="https://i.loli.net/2020/04/22/3K61nlM5RjyPaQF.gif" alt="vp_5.gif"></p><p>完。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用-PagerAdapter-notifyDataSetChange-不刷新问题分析&quot;&gt;&lt;a href=&quot;#使用-PagerAdapter-notifyDataSetChange-不刷新问题分析&quot; class=&quot;headerlink&quot; title=&quot;使用 Pag
      
    
    </summary>
    
    
      <category term="android" scheme="https://maxiaozhou1234.github.io/categories/android/"/>
    
    
      <category term="android" scheme="https://maxiaozhou1234.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>【sqlite】测试题</title>
    <link href="https://maxiaozhou1234.github.io/sqlite/sqlite-test/"/>
    <id>https://maxiaozhou1234.github.io/sqlite/sqlite-test/</id>
    <published>2020-02-26T06:54:21.000Z</published>
    <updated>2020-04-22T15:56:40.687Z</updated>
    
    <content type="html"><![CDATA[<p>数据库测试题</p><h3 id="数据库测试，写出对应的操作-sql-语句"><a href="#数据库测试，写出对应的操作-sql-语句" class="headerlink" title="数据库测试，写出对应的操作 sql 语句"></a>数据库测试，写出对应的操作 sql 语句</h3><h4 id="1-筛选出表A和表B中列【id-name-age】去重后合并输出"><a href="#1-筛选出表A和表B中列【id-name-age】去重后合并输出" class="headerlink" title="1.筛选出表A和表B中列【id,name,age】去重后合并输出"></a>1.筛选出表A和表B中列【id,name,age】去重后合并输出</h4><p>合并选择 union/union all 去重 union<br>前提两个表均包含列【id,name,age】</p><p>select id,name,age from table_A union select id,name,age from table_B;</p><h4 id="2-表1和表2存在id关联关系，将两表列相关联数据全部输出"><a href="#2-表1和表2存在id关联关系，将两表列相关联数据全部输出" class="headerlink" title="2.表1和表2存在id关联关系，将两表列相关联数据全部输出"></a>2.表1和表2存在id关联关系，将两表列相关联数据全部输出</h4><ol><li>存在关联，明显是用 join</li><li>对于单表都有扩展的列，可以用 outer join，inner join</li><li>只要相关联数据，说明是两表都有的数据，使用 inner join。使用 outer join 输出会把缺少的补位 null，属于全量。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from company;</span><br><span class="line">+----+-------+------+------------+--------+</span><br><span class="line">| id | name  | age  | address    | salary |</span><br><span class="line">+----+-------+------+------------+--------+</span><br><span class="line">|  1 | Paul  |   32 | California |  20000 |</span><br><span class="line">|  2 | Allen |   25 | Texas      |  15000 |</span><br><span class="line">|  3 | Teddy |   23 | Norway     |  20000 |</span><br><span class="line">|  4 | Mark  |   25 | Rich-Mond  |  65000 |</span><br><span class="line">|  5 | David |   27 | Texas      |  85000 |</span><br><span class="line">|  6 | Kim   |   22 | South-Hall |  45000 |</span><br><span class="line">|  7 | James |   24 | Houston    |  10000 |</span><br><span class="line">|  8 | Kit   |   30 | NY         |  12000 |</span><br><span class="line">| 10 | Mike  |   17 | NY         |   2000 |</span><br><span class="line">+----+-------+------+------------+--------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from department;</span><br><span class="line">+----+-------------+--------+</span><br><span class="line">| id | dept        | emp_id |</span><br><span class="line">+----+-------------+--------+</span><br><span class="line">|  1 | IT Billing  |      1 |</span><br><span class="line">|  2 | Engineering |      2 |</span><br><span class="line">|  3 | Finance     |      7 |</span><br><span class="line">|  4 | Engineering |      3 |</span><br><span class="line">|  5 | Finance     |      4 |</span><br><span class="line">|  6 | Engineering |      5 |</span><br><span class="line">|  7 | Finance     |      6 |</span><br><span class="line">+----+-------------+--------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>使用 inner join 输出：</p><blockquote><p>mysql&gt; select c.id,c.name,c.salary,d.dept from company c inner join department d on c.id=d.emp_id;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+----+-------+--------+-------------+</span><br><span class="line">| id | name  | salary | dept        |</span><br><span class="line">+----+-------+--------+-------------+</span><br><span class="line">|  1 | Paul  |  20000 | IT Billing  |</span><br><span class="line">|  2 | Allen |  15000 | Engineering |</span><br><span class="line">|  7 | James |  10000 | Finance     |</span><br><span class="line">|  3 | Teddy |  20000 | Engineering |</span><br><span class="line">|  4 | Mark  |  65000 | Finance     |</span><br><span class="line">|  5 | David |  85000 | Engineering |</span><br><span class="line">|  6 | Kim   |  45000 | Finance     |</span><br><span class="line">+----+-------+--------+-------------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><hr><h2 id="对比外连接"><a href="#对比外连接" class="headerlink" title="对比外连接"></a><strong>对比外连接</strong></h2><p>1.使用 company 左外连接 department</p><blockquote><p>mysql&gt; select c.id,c.name,c.salary,d.dept from company c left outer join department d on c.id=d.emp_id;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+----+-------+--------+-------------+</span><br><span class="line">| id | name  | salary | dept        |</span><br><span class="line">+----+-------+--------+-------------+</span><br><span class="line">|  1 | Paul  |  20000 | IT Billing  |</span><br><span class="line">|  2 | Allen |  15000 | Engineering |</span><br><span class="line">|  3 | Teddy |  20000 | Engineering |</span><br><span class="line">|  4 | Mark  |  65000 | Finance     |</span><br><span class="line">|  5 | David |  85000 | Engineering |</span><br><span class="line">|  6 | Kim   |  45000 | Finance     |</span><br><span class="line">|  7 | James |  10000 | Finance     |</span><br><span class="line">|  8 | Kit   |  12000 | NULL        |</span><br><span class="line">| 10 | Mike  |   2000 | NULL        |</span><br><span class="line">+----+-------+--------+-------------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>2.使用 company 右外连接 department （sqlite不支持右外连接可以使用左外连接，调整两个表位置）</p><blockquote><p>mysql&gt; select c.id,c.name,c.salary,d.dept from company c right outer join department d on c.id=d.emp_id;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+------+-------+--------+-------------+</span><br><span class="line">| id   | name  | salary | dept        |</span><br><span class="line">+------+-------+--------+-------------+</span><br><span class="line">|    1 | Paul  |  20000 | IT Billing  |</span><br><span class="line">|    2 | Allen |  15000 | Engineering |</span><br><span class="line">|    7 | James |  10000 | Finance     |</span><br><span class="line">|    3 | Teddy |  20000 | Engineering |</span><br><span class="line">|    4 | Mark  |  65000 | Finance     |</span><br><span class="line">|    5 | David |  85000 | Engineering |</span><br><span class="line">|    6 | Kim   |  45000 | Finance     |</span><br><span class="line">+------+-------+--------+-------------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>上面可以看到，外连接输出与左表、右表相关，题目只要相关联，使用inner join。</p><h4 id="3-表1和表2彼此独立，请列出两表的所有可能组合"><a href="#3-表1和表2彼此独立，请列出两表的所有可能组合" class="headerlink" title="3.表1和表2彼此独立，请列出两表的所有可能组合"></a>3.表1和表2彼此独立，请列出两表的所有可能组合</h4><p>交叉连接<br>select * from table_1 cross join table_2;</p><h4 id="4-表1为员工表，manager-id-为该员工领导id，请通过单表列出员工的-id-name-manager-name"><a href="#4-表1为员工表，manager-id-为该员工领导id，请通过单表列出员工的-id-name-manager-name" class="headerlink" title="4.表1为员工表，manager_id 为该员工领导id，请通过单表列出员工的[id,name,manager_name]"></a>4.表1为员工表，manager_id 为该员工领导id，请通过单表列出员工的[id,name,manager_name]</h4><p>mysql&gt; desc employ;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+------------+----------+------+-----+---------+-------+</span><br><span class="line">| Field      | Type     | Null | Key | Default | Extra |</span><br><span class="line">+------------+----------+------+-----+---------+-------+</span><br><span class="line">| id         | int(11)  | YES  |     | NULL    |       |</span><br><span class="line">| name       | char(20) | YES  |     | NULL    |       |</span><br><span class="line">| salary     | double   | YES  |     | NULL    |       |</span><br><span class="line">| manager_id | int(11)  | YES  |     | NULL    |       |</span><br><span class="line">+------------+----------+------+-----+---------+-------+</span><br><span class="line">4 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>mysql&gt; select * from employ;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+------+------+--------+------------+</span><br><span class="line">| id   | name | salary | manager_id |</span><br><span class="line">+------+------+--------+------------+</span><br><span class="line">|    1 | aa   |   2000 |          3 |</span><br><span class="line">|    2 | bb   |   1000 |          3 |</span><br><span class="line">|    3 | cc   |   2500 |          4 |</span><br><span class="line">|    4 | dd   |   6000 |        100 |</span><br><span class="line">|  100 | ee   |   6000 |          0 |</span><br><span class="line">|    5 | vv   |   3000 |        100 |</span><br><span class="line">+------+------+--------+------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>mysql&gt; select e.id,e.name,e2.name as manager_name from employ e,employ e2 where e.manager_id=e2.id;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+------+------+--------------+</span><br><span class="line">| id   | name | manager_name |</span><br><span class="line">+------+------+--------------+</span><br><span class="line">|    1 | aa   | cc           |</span><br><span class="line">|    2 | bb   | cc           |</span><br><span class="line">|    3 | cc   | dd           |</span><br><span class="line">|    4 | dd   | ee           |</span><br><span class="line">|    5 | vv   | ee           |</span><br><span class="line">+------+------+--------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="5-触发器，表1是用户数据表，uid是操作者id（假设是运维管理），id是新增用户id，需要把表1的增删改操作记录到表log中-uid操作者-action动作-id被操作对象-date时间"><a href="#5-触发器，表1是用户数据表，uid是操作者id（假设是运维管理），id是新增用户id，需要把表1的增删改操作记录到表log中-uid操作者-action动作-id被操作对象-date时间" class="headerlink" title="5.触发器，表1是用户数据表，uid是操作者id（假设是运维管理），id是新增用户id，需要把表1的增删改操作记录到表log中[uid操作者,action动作,id被操作对象,date时间]"></a>5.触发器，表1是用户数据表，uid是操作者id（假设是运维管理），id是新增用户id，需要把表1的增删改操作记录到表log中[uid操作者,action动作,id被操作对象,date时间]</h4><p>表1：create table user (id int primary key auto_increment,name char(20),age int check(age&gt;0),uid int);</p><p>mysql&gt; desc user;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-------+----------+------+-----+---------+----------------+</span><br><span class="line">| Field | Type     | Null | Key | Default | Extra          |</span><br><span class="line">+-------+----------+------+-----+---------+----------------+</span><br><span class="line">| id    | int(11)  | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| name  | char(20) | YES  |     | NULL    |                |</span><br><span class="line">| age   | int(11)  | YES  |     | NULL    |                |</span><br><span class="line">| uid   | int(11)  | YES  |     | NULL    |                |</span><br><span class="line">+-------+----------+------+-----+---------+----------------+</span><br><span class="line">4 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>表2：create table user_log (uid int,action char(20),id int,time timestamp default CURRENT_TIMESTAMP);</p><p>mysql&gt; desc user_log;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+--------+-----------+------+-----+-------------------+-------+</span><br><span class="line">| Field  | Type      | Null | Key | Default           | Extra |</span><br><span class="line">+--------+-----------+------+-----+-------------------+-------+</span><br><span class="line">| uid    | int(11)   | YES  |     | NULL              |       |</span><br><span class="line">| action | char(20)  | YES  |     | NULL              |       |</span><br><span class="line">| id     | int(11)   | YES  |     | NULL              |       |</span><br><span class="line">| time   | timestamp | NO   |     | CURRENT_TIMESTAMP |       |</span><br><span class="line">+--------+-----------+------+-----+-------------------+-------+</span><br><span class="line">4 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>创建触发器。由于 MySQL 5.5只支持单事件触发，所以需要三个对应触发器</p><ol><li><p>增</p><blockquote><p>mysql&gt; create trigger user_insert after insert on user<br> -&gt; for each row<br> -&gt; BEGIN<br> -&gt; insert into user_log(uid,action,id) values (new.uid,’create’,new.id);<br> -&gt; END;<br> -&gt; //<br>Query OK, 0 rows affected (0.06 sec)</p></blockquote></li><li><p>改</p><blockquote><p>mysql&gt; create trigger user_update after update on user<br> -&gt; for each row<br> -&gt; BEGIN<br> -&gt; insert into user_log(uid,action,id) values (old.uid,’update’,old.id);<br> -&gt; END;<br> -&gt; //<br>Query OK, 0 rows affected (0.05 sec)</p></blockquote></li><li><p>删</p><blockquote><p>mysql&gt; create trigger user_delete after delete on user<br> -&gt; for each row<br> -&gt; BEGIN<br> -&gt; insert into user_log(uid,action,id) values (old.uid,’delete’,old.id);<br> -&gt; END;<br> -&gt; //<br>Query OK, 0 rows affected (0.08 sec)</p></blockquote></li></ol><p>测试：</p><pre><code>mysql&gt; select * from user;Empty set (0.00 sec)mysql&gt; select * from user_log;Empty set (0.00 sec)mysql&gt; insert into user (uid,name,age)values (1000,&apos;aka&apos;,10);Query OK, 1 row affected (0.03 sec)mysql&gt; insert into user (uid,name,age)values (1000,&apos;mille&apos;,19);Query OK, 1 row affected (0.03 sec)mysql&gt; insert into user (uid,name,age)values (1003,&apos;jim&apos;,22);Query OK, 1 row affected (0.03 sec)mysql&gt; update user set name=&apos;Sare&apos; where id=&apos;1&apos;;Query OK, 1 row affected (0.02 sec)Rows matched: 1  Changed: 1  Warnings: 0mysql&gt; delete from user where id=2;Query OK, 1 row affected (0.03 sec)</code></pre><p>结果显示：<br>mysql&gt; select * from user;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+----+-------+------+------+</span><br><span class="line">| id | name | age  | uid  |</span><br><span class="line">+----+-------+------+------+</span><br><span class="line">|  1 | Sare |   10 | 1000 |</span><br><span class="line">|  3 | jim  |   22 | 1003 |</span><br><span class="line">+----+-------+------+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>mysql&gt; select * from user_log;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+------+--------+------+---------------------+</span><br><span class="line">| uid  | action | id   | time                |</span><br><span class="line">+------+--------+------+---------------------+</span><br><span class="line">| 1000 | create |    1 | 2020-02-26 10:59:26 |</span><br><span class="line">| 1000 | create |    2 | 2020-02-26 10:59:43 |</span><br><span class="line">| 1003 | create |    3 | 2020-02-26 11:00:12 |</span><br><span class="line">| 1000 | update |    1 | 2020-02-26 11:01:02 |</span><br><span class="line">| 1000 | delete |    2 | 2020-02-26 11:01:39 |</span><br><span class="line">+------+--------+------+---------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数据库测试题&lt;/p&gt;
&lt;h3 id=&quot;数据库测试，写出对应的操作-sql-语句&quot;&gt;&lt;a href=&quot;#数据库测试，写出对应的操作-sql-语句&quot; class=&quot;headerlink&quot; title=&quot;数据库测试，写出对应的操作 sql 语句&quot;&gt;&lt;/a&gt;数据库测试，写出对应的操
      
    
    </summary>
    
    
      <category term="sqlite" scheme="https://maxiaozhou1234.github.io/categories/sqlite/"/>
    
    
      <category term="sqlite" scheme="https://maxiaozhou1234.github.io/tags/sqlite/"/>
    
  </entry>
  
  <entry>
    <title>【sqlite】VIEW 视图</title>
    <link href="https://maxiaozhou1234.github.io/sqlite/sqlite-view/"/>
    <id>https://maxiaozhou1234.github.io/sqlite/sqlite-view/</id>
    <published>2020-02-25T10:08:50.000Z</published>
    <updated>2020-04-22T15:56:40.688Z</updated>
    
    <content type="html"><![CDATA[<p>sqlite view 视图</p><h3 id="View-视图"><a href="#View-视图" class="headerlink" title="View 视图"></a>View 视图</h3><p>视图（View）可以包含一个表的所有行或从一个或多个表选定行。视图（View）可以从一个或多个表创建，这取决于要创建视图的 SQLite 查询。</p><h4 id="1-创建视图语法"><a href="#1-创建视图语法" class="headerlink" title="1.创建视图语法"></a>1.创建视图语法</h4><blockquote><p>CREATE [TEMP | TEMPORARY] VIEW view_name AS<br>SELECT column1, column2…..<br>FROM table_name<br>WHERE [condition];</p></blockquote><h4 id="2-创建视图实例"><a href="#2-创建视图实例" class="headerlink" title="2.创建视图实例"></a>2.创建视图实例</h4><p>你可以只从一个表中取其中几列做为新视图，这里用两个表合并为一个视图。</p><blockquote><p>mysql&gt; create view company_view as select e.id,e.name,e.age,d.dept from company e inner join department d where e.id=d.e<br>mp_id;<br>Query OK, 0 rows affected (0.03 sec)   </p></blockquote><p> mysql&gt; select * from company_view;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+----+-------+------+-------------+</span><br><span class="line">| id | name  | age  | dept        |</span><br><span class="line">+----+-------+------+-------------+</span><br><span class="line">|  1 | Paul  |   32 | IT Billing  |</span><br><span class="line">|  2 | Allen |   25 | Engineering |</span><br><span class="line">|  7 | James |   24 | Finance     |</span><br><span class="line">|  3 | Teddy |   23 | Engineering |</span><br><span class="line">|  4 | Mark  |   25 | Finance     |</span><br><span class="line">|  5 | David |   27 | Engineering |</span><br><span class="line">|  6 | Kim   |   22 | Finance     |</span><br><span class="line">+----+-------+------+-------------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="3-删除视图"><a href="#3-删除视图" class="headerlink" title="3.删除视图"></a>3.删除视图</h4><blockquote><p>drop view view_name</p></blockquote><p>mysql&gt; show tables;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+</span><br><span class="line">| Tables_in_learn_db |</span><br><span class="line">+--------------------+</span><br><span class="line">| company            |</span><br><span class="line">| company_view       |</span><br><span class="line">| department         |</span><br><span class="line">| employ             |</span><br><span class="line">| log                |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><blockquote><p>mysql&gt; drop view company_view;<br>Query OK, 0 rows affected (0.00 sec)</p></blockquote><p>mysql&gt; show tables;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+</span><br><span class="line">| Tables_in_learn_db |</span><br><span class="line">+--------------------+</span><br><span class="line">| company            |</span><br><span class="line">| department         |</span><br><span class="line">| employ             |</span><br><span class="line">| log                |</span><br><span class="line">+--------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;sqlite view 视图&lt;/p&gt;
&lt;h3 id=&quot;View-视图&quot;&gt;&lt;a href=&quot;#View-视图&quot; class=&quot;headerlink&quot; title=&quot;View 视图&quot;&gt;&lt;/a&gt;View 视图&lt;/h3&gt;&lt;p&gt;视图（View）可以包含一个表的所有行或从一个或多个表选
      
    
    </summary>
    
    
      <category term="sqlite" scheme="https://maxiaozhou1234.github.io/categories/sqlite/"/>
    
    
      <category term="sqlite" scheme="https://maxiaozhou1234.github.io/tags/sqlite/"/>
    
  </entry>
  
  <entry>
    <title>【sqlite】Trigger 触发器</title>
    <link href="https://maxiaozhou1234.github.io/sqlite/sqlite-trigger/"/>
    <id>https://maxiaozhou1234.github.io/sqlite/sqlite-trigger/</id>
    <published>2020-02-25T05:34:25.000Z</published>
    <updated>2020-04-22T15:56:40.688Z</updated>
    
    <content type="html"><![CDATA[<p>sqlite Trigger 触发器</p><h3 id="Trigger-触发器"><a href="#Trigger-触发器" class="headerlink" title="Trigger 触发器"></a>Trigger 触发器</h3><p>SQLite 触发器（Trigger）是数据库的回调函数，它会在指定的数据库事件发生时自动执行/调用。<br>指定在特定的数据库表发生 DELETE、INSERT 或 UPDATE 时触发，或在一个或多个指定表的列发生更新时触发。</p><p><a href="https://www.runoob.com/sqlite/sqlite-trigger.html" target="_blank" rel="noopener">Trigger 详细资料链接</a></p><h4 id="1-语法"><a href="#1-语法" class="headerlink" title="1.语法"></a>1.语法</h4><blockquote><p>CREATE  TRIGGER trigger_name [BEFORE|AFTER] event_name[INSERT|UPDATE|DELETE] ON table_name<br>FOR EACH ROW（对 SQLite 可加可不加）<br>BEGIN<br> – 触发器逻辑….<br>END;</p></blockquote><h4 id="2-SQLite-使用触发器"><a href="#2-SQLite-使用触发器" class="headerlink" title="2.SQLite 使用触发器"></a>2.SQLite 使用触发器</h4><h5 id="1）创建记录表，用于存储触发后数据"><a href="#1）创建记录表，用于存储触发后数据" class="headerlink" title="1）创建记录表，用于存储触发后数据"></a>1）创建记录表，用于存储触发后数据</h5><p>create table log(uid int,entry_date text);</p><h5 id="2-创建触发器"><a href="#2-创建触发器" class="headerlink" title="2)创建触发器"></a>2)创建触发器</h5><p>create TRIGGER emp_log AFTER INSERT ON employ<br>BEGIN<br>INSERT INTO log(uid,rtime) values (new.id,datetime(‘now’,’localtime’));<br>END;</p><h5 id="3-向-employ-插入数据，查看log中记录"><a href="#3-向-employ-插入数据，查看log中记录" class="headerlink" title="3)向 employ 插入数据，查看log中记录"></a>3)向 employ 插入数据，查看log中记录</h5><blockquote><p>insert into employ values(5,’vv’,3000,100);</p></blockquote><p>因为没有创建新表，所以存在之前的数据，旧数据再触发器之前存在是不会新增记录在 log 表中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+------+------+--------+------------+</span><br><span class="line">| id   | name | salary | manager_id |</span><br><span class="line">+------+------+--------+------------+</span><br><span class="line">|    1 | aa   |   2000 |          3 |</span><br><span class="line">|    2 | bb   |   1000 |          3 |</span><br><span class="line">|    3 | cc   |   2500 |          4 |</span><br><span class="line">|    4 | dd   |   6000 |        100 |</span><br><span class="line">|  100 | ee   |   6000 |          0 |</span><br><span class="line">|    5 | vv   |   3000 |        100 |</span><br><span class="line">+------+------+--------+------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>log 中记录</p><blockquote><p>select * from log;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+------+----------------------+</span><br><span class="line">| uid  |     entry_date       |</span><br><span class="line">+------+----------------------+</span><br><span class="line">|5     | 2020-02-25 13: 07:02 |</span><br><span class="line">+------+----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="2-MySQL-使用触发器"><a href="#2-MySQL-使用触发器" class="headerlink" title="2.MySQL 使用触发器"></a>2.MySQL 使用触发器</h4><p>使用 MySQL 添加触发器语法和上面一致<br><strong>注意:</strong></p><ul><li>如果是在命令行中执行MySQL，需要将delimiter ; 更改为delimiter //，MySQL 默认使用分号 <strong>“;”</strong> 结束判断，不更改在遇到分号执行语句会导致提示语法错误导致创建触发器失败</li><li>需要增加 <strong>FOR EACH ROW</strong>， MySQL 不支持语句触发器,仅仅支持行级触发器，必须增加这句</li></ul><p>示例如下：</p><blockquote><p>mysql&gt; delimiter //<br>mysql&gt; CREATE TRIGGER emp_log AFTER INSERT ON employ<br>    -&gt; FOR EACH ROW<br>    -&gt; BEGIN<br>    -&gt; INSERT INTO log(uid) values (new.id);<br>    -&gt; END;<br>    -&gt; //<br>Query OK, 0 rows affected (0.08 sec)</p></blockquote><p>最后可以重新把分号执行修改回来，在命令行输入</p><blockquote><p>mysql&gt; delimiter ;</p></blockquote><h4 id="3-MySQL-触发器查询，删除"><a href="#3-MySQL-触发器查询，删除" class="headerlink" title="3.MySQL 触发器查询，删除"></a>3.MySQL 触发器查询，删除</h4><h5 id="1-查询所有触发器"><a href="#1-查询所有触发器" class="headerlink" title="1)查询所有触发器"></a>1)查询所有触发器</h5><blockquote><p>show triggers;</p></blockquote><h5 id="2-删除触发器"><a href="#2-删除触发器" class="headerlink" title="2)删除触发器"></a>2)删除触发器</h5><blockquote><p>drop trigger xxx; (xxx 为触发器名称）</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;sqlite Trigger 触发器&lt;/p&gt;
&lt;h3 id=&quot;Trigger-触发器&quot;&gt;&lt;a href=&quot;#Trigger-触发器&quot; class=&quot;headerlink&quot; title=&quot;Trigger 触发器&quot;&gt;&lt;/a&gt;Trigger 触发器&lt;/h3&gt;&lt;p&gt;SQLite 触
      
    
    </summary>
    
    
      <category term="sqlite" scheme="https://maxiaozhou1234.github.io/categories/sqlite/"/>
    
    
      <category term="sqlite" scheme="https://maxiaozhou1234.github.io/tags/sqlite/"/>
    
  </entry>
  
  <entry>
    <title>【sqlite】unions 语法笔记</title>
    <link href="https://maxiaozhou1234.github.io/sqlite/sqlite-union/"/>
    <id>https://maxiaozhou1234.github.io/sqlite/sqlite-union/</id>
    <published>2020-02-25T03:30:03.000Z</published>
    <updated>2020-04-22T15:56:40.688Z</updated>
    
    <content type="html"><![CDATA[<p>SQLite unions 合并查询</p><blockquote><p>SQLite的 UNION 子句/运算符用于合并两个或多个 SELECT 语句的结果，不返回任何重复的行。<br>为了使用 UNION，每个 SELECT 被选择的列数必须是相同的，相同数目的列表达式，相同的数据类型，并确保它们有相同的顺序，但它们不必具有相同的长度。</p></blockquote><h3 id="SQLite-unions-合并查询"><a href="#SQLite-unions-合并查询" class="headerlink" title="SQLite unions 合并查询"></a>SQLite unions 合并查询</h3><p>将表1和表2的内容合并输出，<strong>前提是两个表中的列必须一致(列名、顺序)</strong></p><h4 id="1-内联查询"><a href="#1-内联查询" class="headerlink" title="1.内联查询"></a>1.内联查询</h4><blockquote><p>mysql&gt; select emp_id,name,dept from company inner join department on company.id=department.emp_id;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+--------+-------+-------------+</span><br><span class="line">| emp_id | name  | dept        |</span><br><span class="line">+--------+-------+-------------+</span><br><span class="line">|      1 | Paul  | IT Billing  |</span><br><span class="line">|      2 | Allen | Engineering |</span><br><span class="line">|      7 | James | Finance     |</span><br><span class="line">|      3 | Teddy | Engineering |</span><br><span class="line">|      4 | Mark  | Finance     |</span><br><span class="line">|      5 | David | Engineering |</span><br><span class="line">|      6 | Kim   | Finance     |</span><br><span class="line">+--------+-------+-------------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="2-左外连接查询"><a href="#2-左外连接查询" class="headerlink" title="2.左外连接查询"></a>2.左外连接查询</h4><blockquote><p>mysql&gt; select emp_id,name,dept from company left outer join department on company.id=department.emp_id;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+--------+-------+-------------+</span><br><span class="line">| emp_id | name  | dept        |</span><br><span class="line">+--------+-------+-------------+</span><br><span class="line">|      1 | Paul  | IT Billing  |</span><br><span class="line">|      2 | Allen | Engineering |</span><br><span class="line">|      3 | Teddy | Engineering |</span><br><span class="line">|      4 | Mark  | Finance     |</span><br><span class="line">|      5 | David | Engineering |</span><br><span class="line">|      6 | Kim   | Finance     |</span><br><span class="line">|      7 | James | Finance     |</span><br><span class="line">+--------+-------+-------------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="3-联合输出"><a href="#3-联合输出" class="headerlink" title="3.联合输出"></a>3.联合输出</h4><blockquote><p>mysql&gt; select emp_id,name,dept from company inner join department on company.id=department.emp_id union select emp_id,na<br>me,dept from company left outer join department on company.id=department.emp_id;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+--------+-------+-------------+</span><br><span class="line">| emp_id | name  | dept        |</span><br><span class="line">+--------+-------+-------------+</span><br><span class="line">|      1 | Paul  | IT Billing  |</span><br><span class="line">|      2 | Allen | Engineering |</span><br><span class="line">|      7 | James | Finance     |</span><br><span class="line">|      3 | Teddy | Engineering |</span><br><span class="line">|      4 | Mark  | Finance     |</span><br><span class="line">|      5 | David | Engineering |</span><br><span class="line">|      6 | Kim   | Finance     |</span><br><span class="line">+--------+-------+-------------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>上面这个例子结果不能很好展现合并的效果，我们更改一下第二条查询的条件，增加员工id&lt;5，如下</p><blockquote><p>mysql&gt;select emp_id,name,dept from company left outer join department on company.id=department.emp_id and company.id&lt;5;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+--------+-------+-------------+</span><br><span class="line">| emp_id | name  | dept        |</span><br><span class="line">+--------+-------+-------------+</span><br><span class="line">|      1 | Paul  | IT Billing  |</span><br><span class="line">|      2 | Allen | Engineering |</span><br><span class="line">|      3 | Teddy | Engineering |</span><br><span class="line">|      4 | Mark  | Finance     |</span><br><span class="line">|   NULL | David | NULL        |</span><br><span class="line">|   NULL | Kim   | NULL        |</span><br><span class="line">|   NULL | James | NULL        |</span><br><span class="line">+--------+-------+-------------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>这里我们看到左外连接后，id&gt;=5的员工数据被置为null，此时再联合输出：</p><blockquote><p>mysql&gt; select emp_id id,name,dept from company inner join department on company.id=department.emp_id union select emp_id<br>,name,dept from company left outer join department on company.id=department.emp_id and company.id&lt;5;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+------+-------+-------------+</span><br><span class="line">| id   | name  | dept        |</span><br><span class="line">+------+-------+-------------+</span><br><span class="line">|    1 | Paul  | IT Billing  |</span><br><span class="line">|    2 | Allen | Engineering |</span><br><span class="line">|    7 | James | Finance     |</span><br><span class="line">|    3 | Teddy | Engineering |</span><br><span class="line">|    4 | Mark  | Finance     |</span><br><span class="line">|    5 | David | Engineering |</span><br><span class="line">|    6 | Kim   | Finance     |</span><br><span class="line">| NULL | David | NULL        |</span><br><span class="line">| NULL | Kim   | NULL        |</span><br><span class="line">| NULL | James | NULL        |</span><br><span class="line">+------+-------+-------------+</span><br><span class="line">10 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>查询后可以看到，表1的查询结果都在，表2中1-4数据和表1相同合并为一，剩下三条再并表输出，总共数据为7+3 = 10条。</p><h4 id="4-union-all-合并所有"><a href="#4-union-all-合并所有" class="headerlink" title="4.union all 合并所有"></a>4.union all 合并所有</h4><p>仅使用 union 关键字，重复的项会被过滤，如果要保留两个表中的所有内容，可以使用<strong>union all</strong>合并所有数据。<br>将上面的例子修改一下：</p><blockquote><p>mysql&gt; select emp_id id,name,dept from company inner join department on company.id=department.emp_id union all select em<br>p_id,name,dept from company left outer join department on company.id=department.emp_id and company.id&lt;5;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+------+-------+-------------+</span><br><span class="line">| id   | name  | dept        |</span><br><span class="line">+------+-------+-------------+</span><br><span class="line">|    1 | Paul  | IT Billing  |</span><br><span class="line">|    2 | Allen | Engineering |</span><br><span class="line">|    7 | James | Finance     |</span><br><span class="line">|    3 | Teddy | Engineering |</span><br><span class="line">|    4 | Mark  | Finance     |</span><br><span class="line">|    5 | David | Engineering |</span><br><span class="line">|    6 | Kim   | Finance     |</span><br><span class="line">|    1 | Paul  | IT Billing  |</span><br><span class="line">|    2 | Allen | Engineering |</span><br><span class="line">|    3 | Teddy | Engineering |</span><br><span class="line">|    4 | Mark  | Finance     |</span><br><span class="line">| NULL | David | NULL        |</span><br><span class="line">| NULL | Kim   | NULL        |</span><br><span class="line">| NULL | James | NULL        |</span><br><span class="line">+------+-------+-------------+</span><br><span class="line">14 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>结果如上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SQLite unions 合并查询&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SQLite的 UNION 子句/运算符用于合并两个或多个 SELECT 语句的结果，不返回任何重复的行。&lt;br&gt;为了使用 UNION，每个 SELECT 被选择的列数必须是相同的，相同数目的列表
      
    
    </summary>
    
    
      <category term="sqlite" scheme="https://maxiaozhou1234.github.io/categories/sqlite/"/>
    
    
      <category term="sqlite" scheme="https://maxiaozhou1234.github.io/tags/sqlite/"/>
    
  </entry>
  
  <entry>
    <title>【sqlite】join 语法笔记</title>
    <link href="https://maxiaozhou1234.github.io/sqlite/sqlite-join/"/>
    <id>https://maxiaozhou1234.github.io/sqlite/sqlite-join/</id>
    <published>2020-02-25T02:01:00.000Z</published>
    <updated>2020-04-22T15:56:40.687Z</updated>
    
    <content type="html"><![CDATA[<p>SQLite 数据库 join 语法笔记</p><h3 id="SQLite-关键字-join"><a href="#SQLite-关键字-join" class="headerlink" title="SQLite 关键字 join"></a>SQLite 关键字 join</h3><h4 id="1-cross-join-交叉连接"><a href="#1-cross-join-交叉连接" class="headerlink" title="1.cross join 交叉连接"></a>1.cross join 交叉连接</h4><p>把第一个表的每一行和第二个表的每一行进行匹配。如表1有m行，表2有n行，交叉连接之后有 m*n 行。</p><p><strong>select * from company;</strong></p><p><img src="https://i.loli.net/2020/02/24/eFaoVbMcN9fzvnU.png" alt="1.png"></p><p><strong>select * from department;</strong></p><p><img src="https://i.loli.net/2020/02/24/NLHugBocmZ5IdFC.png" alt="2.png"></p><p><strong>select emp_id,name,dept from company cross join department;</strong></p><p><img src="https://i.loli.net/2020/02/24/YzhkEsmfAxjnSpv.png" alt="3.png"></p><h4 id="2-inner-join-内联"><a href="#2-inner-join-内联" class="headerlink" title="2.inner join 内联"></a>2.inner join 内联</h4><p>根据连接条件结合两个表的列值创建一个新的结果表。<br>内连接语法：</p><ol><li><blockquote><p>SELECT … FROM table1 [INNER] JOIN table2 ON conditional_expression …</p></blockquote></li><li><p>为了避免冗余，并保持较短的措辞，可以使用 USING 表达式声明内连接（INNER JOIN）条件。这个表达式指定一个或多个列的列表：<strong>注：如果两张表的关联字段名相同，才可以使用USING子句</strong> </p><blockquote><p>SELECT … FROM table1 JOIN table2 USING ( column1 ,… ) …</p></blockquote></li><li><p>自然连接（NATURAL JOIN）类似于 JOIN…USING，只是它会自动测试存在两个表中的每一列的值之间相等值：</p><blockquote><p>SELECT … FROM table1 NATURAL JOIN table2…</p></blockquote></li></ol><p>示例：<br><strong>select emp_id,name,dept from company inner join department on company.id=department.emp_id;</strong></p><p><img src="https://i.loli.net/2020/02/24/bRU9NXdnQfkBwlr.png" alt="4.png"></p><h4 id="3-outer-join-外连接"><a href="#3-outer-join-外连接" class="headerlink" title="3.outer join 外连接"></a>3.outer join 外连接</h4><p>外连接（OUTER JOIN）是内连接（INNER JOIN）的扩展。虽然 SQL 标准定义了三种类型的外连接：LEFT、RIGHT、FULL，<strong>但 SQLite 只支持 左外连接（LEFT OUTER JOIN）</strong>。</p><ol><li>左连接 left outer join/left join<br>关联两张或多张表中，根据条件显示匹配的数据。依附于左表进行扩展，扩展后表中内容如果右表没有匹配数据，则用 null 显示。</li><li>右连接 right outer join/right join<br>关联两张或多张表中，根据条件显示匹配的数据。依附于右表进行扩展，扩展后表中内容如果左表没有匹配数据，则用 null 显示。</li><li>全连接 full outer join/right join<br>全外连接就是关联的两张或多张表中，根据关联条件，显示所有匹配和不匹配的记录。<br>左表中有的记录，但是右表中没有匹配上的，以空(null)显示。右表中有的记录，但是左表中没有匹配上的，也以空(null)显示。<br>FULL OUTER JOIN也可以简写成FULL JOIN，效果是一样的。</li></ol><p>左外连接语法：</p><ol><li><blockquote><p>SELECT … FROM table1 LEFT OUTER JOIN table2 ON [conditional_expression 条件] …</p></blockquote></li><li><p>为了避免冗余，可以使用 <strong>using</strong> 声明条件 </p><blockquote><p>SELECT … FROM table1 LEFT OUTER JOIN table2 USING ( column1 ,… ) …</p></blockquote></li></ol><p>示例：<br><strong>select emp_id,name,dept from company left outer join department on company.id=department.emp_id;</strong></p><p><img src="https://i.loli.net/2020/02/24/QgiYNUvdqa1JRwm.png" alt="5.png"></p><h4 id="4-自连接，扩展"><a href="#4-自连接，扩展" class="headerlink" title="4.自连接，扩展"></a>4.自连接，扩展</h4><p>只有一张表，通过把表取别名，当作两张表使用，自己和自己关联。</p><p>示例：查询经理的名称，通过员工id和经理id相同自连接查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">create table employ (id int,name char(20),salary real check(salary &gt;0),manager_id int);</span><br><span class="line"></span><br><span class="line">insert into employ values (1,&#39;aa&#39;,2000,3);</span><br><span class="line">insert into employ values (2,&#39;bb&#39;,1000,3);</span><br><span class="line">insert into employ values (3,&#39;cc&#39;,2500,4);</span><br><span class="line">insert into employ values (4,&#39;dd&#39;,6000,100);</span><br><span class="line">insert into employ values (100,&#39;ee&#39;,6000,0);</span><br><span class="line"></span><br><span class="line">默认使用 inner join，同样也可以使用left join</span><br><span class="line">select e.name,e.salary,e2.name manager from employ e ，employ e2 on e.manager_id &#x3D; e2.id;</span><br><span class="line"></span><br><span class="line">使用条件 where</span><br><span class="line">select e.name,e.salary,e2.name manager from employ e , employ e2 where e.manager_id &#x3D; e2.id;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/24/7ut5ZO6Vsm8aNiX.png" alt="6.png"></p><hr><p>图片存储记录：<br><a href="https://i.loli.net/2020/02/24/eFaoVbMcN9fzvnU.png" target="_blank" rel="noopener">1.png</a><br><a href="https://i.loli.net/2020/02/24/NLHugBocmZ5IdFC.png" target="_blank" rel="noopener">2.png</a><br><a href="https://i.loli.net/2020/02/24/7ut5ZO6Vsm8aNiX.png" target="_blank" rel="noopener">6.png</a><br><a href="https://i.loli.net/2020/02/24/bRU9NXdnQfkBwlr.png" target="_blank" rel="noopener">4.png</a><br><a href="https://i.loli.net/2020/02/24/QgiYNUvdqa1JRwm.png" target="_blank" rel="noopener">5.png</a><br><a href="https://i.loli.net/2020/02/24/YzhkEsmfAxjnSpv.png" target="_blank" rel="noopener">3.png</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SQLite 数据库 join 语法笔记&lt;/p&gt;
&lt;h3 id=&quot;SQLite-关键字-join&quot;&gt;&lt;a href=&quot;#SQLite-关键字-join&quot; class=&quot;headerlink&quot; title=&quot;SQLite 关键字 join&quot;&gt;&lt;/a&gt;SQLite 关键字 jo
      
    
    </summary>
    
    
      <category term="sqlite" scheme="https://maxiaozhou1234.github.io/categories/sqlite/"/>
    
    
      <category term="sqlite" scheme="https://maxiaozhou1234.github.io/tags/sqlite/"/>
    
  </entry>
  
  <entry>
    <title>【MySQL】操作命令</title>
    <link href="https://maxiaozhou1234.github.io/sqlite/mysql-cmd/"/>
    <id>https://maxiaozhou1234.github.io/sqlite/mysql-cmd/</id>
    <published>2020-02-25T02:00:00.000Z</published>
    <updated>2020-04-22T15:56:40.686Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL 基本操作命令</p><h3 id="MySQL-基本操作命令"><a href="#MySQL-基本操作命令" class="headerlink" title="MySQL 基本操作命令"></a>MySQL 基本操作命令</h3><ol><li>查看所有数据库<br>show databases;</li><li>使用数据库<br>use xxx;</li><li>创建数据库<br>create database xxx charset=utf8;//创建xx数据库，并指定编码</li><li>查看创建数据库时的语法命令<br>show create database xxx;</li><li>查看数据库中所有的表<br>show tables;</li><li>删除数据库<br>drop database xxx;</li><li>查看所有触发器<br>show triggers;</li><li>查看指定表触发器（使用 \G 切换视图为纵向输出）<br>select * from information_schema.triggers where EVENT_OBJECT_TABLE=’table_name’;</li><li>删除触发器<br>drop trigger trigger_name;</li><li>查看表结构<br>desc table;<br>describe table;</li><li>创建视图<br>create view view_name as select column1[…] from table where [condition];</li><li>删除视图<br>drop view name; </li></ol><h3 id="MySQL-5-5版本注意"><a href="#MySQL-5-5版本注意" class="headerlink" title="MySQL 5.5版本注意"></a>MySQL 5.5版本注意</h3><ol><li>没有 datatime,如需要使用时间戳，用<strong>timestmap</strong>代替</li><li>默认使用分号<strong>；</strong>结束判断，如果需要多行输入，将delimiter ; 更改为delimiter //，按<strong>“//”</strong>为结束判断 </li><li>没有 datetime ，时间戳使用 timestamp</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MySQL 基本操作命令&lt;/p&gt;
&lt;h3 id=&quot;MySQL-基本操作命令&quot;&gt;&lt;a href=&quot;#MySQL-基本操作命令&quot; class=&quot;headerlink&quot; title=&quot;MySQL 基本操作命令&quot;&gt;&lt;/a&gt;MySQL 基本操作命令&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;查看所有
      
    
    </summary>
    
    
      <category term="sqlite" scheme="https://maxiaozhou1234.github.io/categories/sqlite/"/>
    
    
      <category term="MySQL" scheme="https://maxiaozhou1234.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>【java】NIO 小结</title>
    <link href="https://maxiaozhou1234.github.io/java/java-nio/"/>
    <id>https://maxiaozhou1234.github.io/java/java-nio/</id>
    <published>2020-02-11T09:15:45.000Z</published>
    <updated>2020-04-22T15:56:40.686Z</updated>
    
    <content type="html"><![CDATA[<p>java NIO 学习后的小结</p><h3 id="1-NIO-总述"><a href="#1-NIO-总述" class="headerlink" title="1. NIO 总述"></a>1. NIO 总述</h3><p>nio 为 Non-blocking io，即不阻塞io操作，java在为并发提供的 io 操作类，主要有三个核心类，分别为：</p><ul><li>Channel 操作数据通道</li><li>Buffer 缓冲数据区域</li><li>Selector 用于管理 channel</li></ul><h3 id="2-BIO-与-NIO-的主要区别"><a href="#2-BIO-与-NIO-的主要区别" class="headerlink" title="2. BIO 与 NIO 的主要区别"></a>2. BIO 与 NIO 的主要区别</h3><h4 id="2-1-面向操作"><a href="#2-1-面向操作" class="headerlink" title="2.1 面向操作"></a>2.1 面向操作</h4><p>BIO 是面向流操作，NIO 是面向缓冲操作。BIO 每次从流读写一个或多个字节，直至所有字节被读写完成，该过程数据没有被缓存到其它地方，它不能前后移动流中的数据。</p><p>NIO 将数据先缓冲到稍后处理的区域，需要时可以在缓冲区前后移动，具备处理过程中的灵活性。</p><h4 id="2-2-阻塞与非阻塞"><a href="#2-2-阻塞与非阻塞" class="headerlink" title="2.2 阻塞与非阻塞"></a>2.2 阻塞与非阻塞</h4><p>Java IO 流失阻塞的，意味着，当线程调用 read（）或 write（）时，该线程被阻塞，直到数据完全读取或者写入，期间线程无法进行其它处理。</p><p>NIO 的非阻塞模式，可以让线程请求写入一些数据到某通道，但不需要等到操作完成，这个现场同时可以去做其他事情。线程通常将非阻塞IO空闲时间用于其他通道上执行IO操作，所以一个线程可以管理多个输入、输出通道。</p><h4 id="2-3-选择器"><a href="#2-3-选择器" class="headerlink" title="2.3 选择器"></a>2.3 选择器</h4><p>NIO 的选择器允许一个单独线程监视多个输入通道，可以注册多个通道使用一个选择器，然后监控可以处理的输入通道进行操作。</p><h3 id="3-NIO-中的-channel"><a href="#3-NIO-中的-channel" class="headerlink" title="3. NIO 中的 channel"></a>3. NIO 中的 channel</h3><h4 id="3-1-FileChannel"><a href="#3-1-FileChannel" class="headerlink" title="3.1 FileChannel"></a>3.1 FileChannel</h4><p>FileChannel 可以通过 <code>RandomAccessFile.getChannel()</code> 或 <code>InputStream,OutputStream .getChannel()</code> 获取，示例代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">channelCopy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Instant begin = Instant.now();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        RandomAccessFile source = <span class="keyword">new</span> RandomAccessFile(<span class="string">"./res/threeWithoutPunctuation"</span>, <span class="string">"r"</span>);</span><br><span class="line">        RandomAccessFile target = <span class="keyword">new</span> RandomAccessFile(<span class="string">"./res/copyFileNio"</span>, <span class="string">"rw"</span>);</span><br><span class="line"></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>*<span class="number">8</span>);</span><br><span class="line">        FileChannel sourceChannel = source.getChannel();</span><br><span class="line">        FileChannel targetChannel = target.getChannel();</span><br><span class="line">        <span class="keyword">while</span> (sourceChannel.read(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                targetChannel.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        sourceChannel.close();</span><br><span class="line">        targetChannel.close();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"[channelCopy] Done &gt;&gt; "</span> + (Duration.between(begin, Instant.now()).toMillis()) + <span class="string">" ms"</span>);</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">测试在小文件复制速度可能不如流操作，但在大文件拷贝速度比流复制快，测试拷贝<span class="number">1.03</span>G文件，channel 耗时 <span class="number">1.08</span>s，而 stream 需要 <span class="number">11.31</span>s。</span><br><span class="line"></span><br><span class="line">#### 3.2 DatagramChannel</span><br><span class="line">DatagramChannel 广播包的操作，区别不大，示例代码如下：</span><br><span class="line"></span><br><span class="line">服务端</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">private</span> SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>, Locale.getDefault());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        DatagramChannel datagramChannel = DatagramChannel.open();</span><br><span class="line">        datagramChannel.configureBlocking(<span class="keyword">true</span>);</span><br><span class="line">        datagramChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8000</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"启动服务端"</span>);</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        SocketAddress socketAddress;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//超过buffer大小部分将被丢弃</span></span><br><span class="line">            <span class="keyword">if</span> ((socketAddress = datagramChannel.receive(buffer)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                buffer.flip();</span><br><span class="line">                System.out.println(Charset.forName(<span class="string">"UTF-8"</span>).decode(buffer));</span><br><span class="line">                buffer.clear();</span><br><span class="line">                datagramChannel.send(Charset.forName(<span class="string">"UTF-8"</span>).encode(<span class="string">"服务端已收到["</span> + format.format(<span class="keyword">new</span> Date())), socketAddress);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DatagramNioClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        DatagramChannel datagramChannel = DatagramChannel.open();</span><br><span class="line">        datagramChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8001</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (datagramChannel.receive(buffer) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        System.out.print(<span class="string">"收到消息："</span>);</span><br><span class="line">                        System.out.println(Charset.forName(<span class="string">"UTF-8"</span>).decode(buffer));</span><br><span class="line">                        buffer.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"启动客户端"</span>);</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">            send(datagramChannel, scanner.nextLine());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(DatagramChannel datagramChannel, String msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        datagramChannel.send(Charset.forName(<span class="string">"UTF-8"</span>).encode(msg), <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8000</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需注意，如果接收数据超过设定容器的大小，超过部分会丢弃。比如对方发送了128K数据，而我容器只有48K大小，那么我只接收到48K数据，而剩余部分直接被丢弃。</p><p>对于数据的读取可以传入 ByteBuffer[] 数据，将按照顺序进行填充，对于一些固定大小数据头的数据包，使用非常方便，缺点容量一旦确定不可修改，弹性差，示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    DatagramChannel datagramChannel = DatagramChannel.open();</span><br><span class="line">    datagramChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>,<span class="number">8001</span>));</span><br><span class="line">    ByteBuffer headBuffer = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">    ByteBuffer bodyBuffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">    datagramChannel.read(<span class="keyword">new</span> ByteBuffer[]&#123;headBuffer,bodyBuffer&#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>connect</code> 并非真正的建立连接，而是锁定 channel 通道，让该通道只能通过特定的地址收发数据。 </p><h4 id="3-3-SocketChannel-ServerSocketChannel"><a href="#3-3-SocketChannel-ServerSocketChannel" class="headerlink" title="3.3 SocketChannel,ServerSocketChannel"></a>3.3 SocketChannel,ServerSocketChannel</h4><p>这两个 SocketChannel 是 socket 的并发版本，通常我们通过 <code>ServerSocket</code> 来监听端口，一旦有客户端连接，就创建线程进行通信，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8000</span>);</span><br><span class="line">    Socket socket;</span><br><span class="line">    <span class="keyword">while</span> ((socket = serverSocket.accept()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> Socket ss = socket;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                InputStream in = ss.getInputStream();</span><br><span class="line">                OutputStream out = ss.getOutputStream();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一次连接都需要创建线程进行通信，所以服务端线程数与客户端数量呈1:1关系，线程的创建需要消耗服务器资源，而服务器资源有限，在并发高且传输数据小的环境，这种方式无法满足要求。</p><p>SocketChannel 能够很好的解决高并发下的资源问题，通过 Selector 注册后，在非阻塞模式下仅使用单线程可以管理多个通道并实现数据传输，服务端示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立服务端监听，设置为非阻塞模式</span></span><br><span class="line">    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">    serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8000</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//将 channel 注册到 selector</span></span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line">    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">//检查是否有可处理通道</span></span><br><span class="line">        <span class="keyword">int</span> num = selector.select();</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">continue</span>;<span class="comment">//jdk 中空转有一定几率造成 cpu 100%</span></span><br><span class="line"></span><br><span class="line">        Set&lt;SelectionKey&gt; set = selector.selectedKeys();</span><br><span class="line">        Iterator&lt;SelectionKey&gt; it = set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            SelectionKey key = it.next();</span><br><span class="line"></span><br><span class="line">            it.remove();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (key.isAcceptable()) &#123;<span class="comment">//把通道注册为可读</span></span><br><span class="line"></span><br><span class="line">                ServerSocketChannel channel = (ServerSocketChannel) key.channel();</span><br><span class="line"></span><br><span class="line">                SocketChannel acceptChannel = channel.accept();</span><br><span class="line">                acceptChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                acceptChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;<span class="comment">//处理已连接 channel 数据</span></span><br><span class="line">                SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                <span class="keyword">if</span>(channel.read(buffer)!=-<span class="number">1</span>)&#123;</span><br><span class="line">buffer.flip();</span><br><span class="line">                System.out.println(Charset.forName(<span class="string">"UTF-8"</span>).decode(buffer));</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">channel.write(Charset.forName(<span class="string">"UTF-8"</span>).encode(<span class="string">"回复"</span>));</span><br><span class="line">&#125;</span><br><span class="line">                channel.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出，SocketChannel 在并发量大处理的优越性。</p><p>如果是需要管理成千上万个连接，并且这些连接每次只是发送少量的数据，如聊天服务器这类需求，实现NIO服务器可能是一个优势，但如果是少量连接使用，一次发送大量数据，还是典型的IO服务器实现更符合要求。</p><p>当然 SocketChannel 还是存在缺点，比如注释中写到可能出现cpu占用100%的bug（说已修复但仍有小概率出现），api使用比较复杂，但对于小型的服务处理，NIO服务器仍然是一个高效可用的实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;java NIO 学习后的小结&lt;/p&gt;
&lt;h3 id=&quot;1-NIO-总述&quot;&gt;&lt;a href=&quot;#1-NIO-总述&quot; class=&quot;headerlink&quot; title=&quot;1. NIO 总述&quot;&gt;&lt;/a&gt;1. NIO 总述&lt;/h3&gt;&lt;p&gt;nio 为 Non-blocking io
      
    
    </summary>
    
    
      <category term="java" scheme="https://maxiaozhou1234.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://maxiaozhou1234.github.io/tags/java/"/>
    
      <category term="nio" scheme="https://maxiaozhou1234.github.io/tags/nio/"/>
    
  </entry>
  
  <entry>
    <title>【其他】gittalk 配置问题</title>
    <link href="https://maxiaozhou1234.github.io/default/gittalk/"/>
    <id>https://maxiaozhou1234.github.io/default/gittalk/</id>
    <published>2020-02-11T06:58:05.000Z</published>
    <updated>2020-04-22T15:56:40.686Z</updated>
    
    <content type="html"><![CDATA[<p>使用 gittalk 为 Hexo 添加评论功能，遇到问题及解决方法</p><h3 id="1-申请及配置"><a href="#1-申请及配置" class="headerlink" title="1.申请及配置"></a>1.申请及配置</h3><h4 id="1-1-注册-gittalk"><a href="#1-1-注册-gittalk" class="headerlink" title="1.1 注册 gittalk"></a>1.1 注册 gittalk</h4><p>可通过 <a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">Register a new OAuth application</a> 进行注册。如果已经注册过，可以在 github 首页点击头像下拉，“Settings – Developer settings – OAuth Apps” 查看你的app，选择你注册的 app 进行再次编辑。</p><h4 id="1-2-配置填写"><a href="#1-2-配置填写" class="headerlink" title="1.2 配置填写"></a>1.2 配置填写</h4><ul><li><p>Application name： 应用名称，随意</p></li><li><p>Homepage URL： 网站URL，对应自己博客地址</p></li><li><p>Application description ：描述，随意</p></li><li><p>Authorization callback URL：# 网站URL，博客地址就好</p></li><li><p>点击注册，页面会出现其中Client ID和Client Secret在后面的配置中需要用到</p></li></ul><p>如我的 gittalk 填写如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Application name： CommentApp</span><br><span class="line">Homepage URL： https:&#x2F;&#x2F;maxiaozhou1234.github.io # 网站URL，对应自己博客地址</span><br><span class="line">Application description ：repo # 描述，随意</span><br><span class="line">Authorization callback URL：https:&#x2F;&#x2F;maxiaozhou1234.github.io # 网站URL，博客地址就好，如果有独立域名，可填写你的域名用于跳转</span><br></pre></td></tr></table></figure><h4 id="1-3-在主题的-config-yml-进行配置"><a href="#1-3-在主题的-config-yml-进行配置" class="headerlink" title="1.3 在主题的 _config.yml 进行配置"></a>1.3 在主题的 _config.yml 进行配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#Cmments</span><br><span class="line">comment:</span><br><span class="line">  gitalk:</span><br><span class="line">    enable: true ## 开启gitalk</span><br><span class="line">    owner: ## GitHub的用户名</span><br><span class="line">    repo: ## 此评论存放的GitHub仓库</span><br><span class="line">    client_id: ## 复制刚才生成的clientID，例如. 75752dafe7907a897619</span><br><span class="line">    client_secret: ## 复制刚才生成的clientSecret，例如. ec2fb9054972c891289640354993b662f4cccc50</span><br><span class="line">    admin: ## Github的用户名</span><br><span class="line">id: location.pathname</span><br><span class="line">    language: zh-CN ## Language</span><br><span class="line">    pagerDirection: last # Comment sorting direction, available values are last and first.</span><br></pre></td></tr></table></figure><p>主题的配置，可以参考<a href="https://chaooo.github.io/article/20161229.html" target="_blank" rel="noopener">【Hexo博客折腾】BlueLake博客主题的详细配置</a></p><h3 id="2-搭建过程遇到的问题"><a href="#2-搭建过程遇到的问题" class="headerlink" title="2. 搭建过程遇到的问题"></a>2. 搭建过程遇到的问题</h3><h4 id="2-1-评论区显示-Error-Not-Found"><a href="#2-1-评论区显示-Error-Not-Found" class="headerlink" title="2.1 评论区显示 Error: Not Found"></a>2.1 评论区显示 Error: Not Found</h4><p>遇到 Error: Not Found，这个问题是主题 _config.yml 中 gittalk 配置中 repo 填写错误，修改为你的博客主页即可，如我的博客配置如下：</p><blockquote><p>repo： maxiaozhou1234.github.io</p></blockquote><h4 id="2-2-博客评论登录跳转到首页问题"><a href="#2-2-博客评论登录跳转到首页问题" class="headerlink" title="2.2 博客评论登录跳转到首页问题"></a>2.2 博客评论登录跳转到首页问题</h4><p>申请配置是填写的<code>Homepage URL</code>,<code>Authorization callback URL</code> 不正确导致，第一个填博客首页，第二个是授权回调页面，因为我没有使用独立的域名，所以两个都填博客首页，如下</p><blockquote><p>Homepage URL：<a href="https://maxiaozhou1234.github.io">https://maxiaozhou1234.github.io</a><br>Authorization callback URL：<a href="https://maxiaozhou1234.github.io">https://maxiaozhou1234.github.io</a></p></blockquote><p>如果你是有自己独立的域名，将 <code>Authorization callback URL</code> 填写为你的域名，前提是你已完成了域名的绑定，还有注意 https 和 http 区别，需完全一致。</p><p>参考文章：<a href="https://blog.csdn.net/w47_csdn/article/details/88858343" target="_blank" rel="noopener">解决配置gitalk插件后初始化登录时跳转回首页</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用 gittalk 为 Hexo 添加评论功能，遇到问题及解决方法&lt;/p&gt;
&lt;h3 id=&quot;1-申请及配置&quot;&gt;&lt;a href=&quot;#1-申请及配置&quot; class=&quot;headerlink&quot; title=&quot;1.申请及配置&quot;&gt;&lt;/a&gt;1.申请及配置&lt;/h3&gt;&lt;h4 id=&quot;1-1
      
    
    </summary>
    
    
      <category term="default" scheme="https://maxiaozhou1234.github.io/categories/default/"/>
    
    
      <category term="gittalk" scheme="https://maxiaozhou1234.github.io/tags/gittalk/"/>
    
      <category term="hexo" scheme="https://maxiaozhou1234.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
