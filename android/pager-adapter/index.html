<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="xiaozhou blog"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><link rel="stylesheet" type="text/css" href="https://unpkg.com/gitalk/dist/gitalk.css?v=2.0.4"><title>【Android】PagerAdapter不刷新问题分析 | xiaozhou Blog</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">【Android】PagerAdapter不刷新问题分析</h1><a id="logo" href="/.">xiaozhou Blog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">【Android】PagerAdapter不刷新问题分析</h1><div class="post-meta"><a href="/android/pager-adapter/#comments" class="comment-count"></a><p><span class="date">Apr 22, 2020</span><span><a href="/categories/android/" class="category">android</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="使用-PagerAdapter-notifyDataSetChange-不刷新问题分析"><a href="#使用-PagerAdapter-notifyDataSetChange-不刷新问题分析" class="headerlink" title="使用 PagerAdapter notifyDataSetChange 不刷新问题分析"></a>使用 PagerAdapter notifyDataSetChange 不刷新问题分析</h2><p>无论是普通的 ViewPager 视图，还是用 Fragment，当我们刷新数据后调用 notifyDataSetChange 后，往往会发现当前界面并没有预想的触发刷新，根本原因在于 ViewPager 的缓存机制判定数据未发生变化，从而不触发刷新，及时数据确实发生了改变。</p>
<h3 id="1-未触发刷新效果及分析"><a href="#1-未触发刷新效果及分析" class="headerlink" title="1. 未触发刷新效果及分析"></a>1. 未触发刷新效果及分析</h3><p>假设当前 page 是第一页，第一个数据发生变更，此时调用 notifyDataSetChange 后页面并没有变化，原因在于当前页面没有触发强制刷新，仅仅是从缓存中取数据而已。</p>
<h4 id="1-1-不刷新模拟效果"><a href="#1-1-不刷新模拟效果" class="headerlink" title="1.1 不刷新模拟效果"></a>1.1 不刷新模拟效果</h4><p>ViewPager 默认缓存数是1，即当前页+缓存，总共2，从效果图也可以看出更新数据后，当前页和滑动一页并不会销毁改页，在两页之后回到第一页，之前的页才被销毁，重新创建。</p>
<p>此页面有三个 view 在 ViewPager 中，当点击按钮会更新第一个 view 中的文字，在没有重写 getItemPosition 下，效果如下所示</p>
<p><img src="https://i.loli.net/2020/04/22/OgJVmaLwPqNjShb.gif" alt="vp_2.gif"></p>
<h4 id="1-2-不刷新源码分析"><a href="#1-2-不刷新源码分析" class="headerlink" title="1.2 不刷新源码分析"></a>1.2 不刷新源码分析</h4><p>当然，我们可以从 ViewPager 中看到，当我们调用 notifyDataSetChange 后会回调 VP 的 <code>void dataSetChanged()</code>，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">void dataSetChanged() &#123;</span><br><span class="line">	&#x2F;&#x2F; This method only gets called if our observer is attached, so mAdapter is non-null.</span><br><span class="line"></span><br><span class="line">    final int adapterCount &#x3D; mAdapter.getCount();</span><br><span class="line">    mExpectedAdapterCount &#x3D; adapterCount;</span><br><span class="line">    boolean needPopulate &#x3D; mItems.size() &lt; mOffscreenPageLimit * 2 + 1</span><br><span class="line">            &amp;&amp; mItems.size() &lt; adapterCount;</span><br><span class="line">    int newCurrItem &#x3D; mCurItem;</span><br><span class="line"></span><br><span class="line">    boolean isUpdating &#x3D; false;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; mItems.size(); i++) &#123;</span><br><span class="line">        final ItemInfo ii &#x3D; mItems.get(i);</span><br><span class="line">		&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;核心方法&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">        final int newPos &#x3D; mAdapter.getItemPosition(ii.object);</span><br><span class="line"></span><br><span class="line">        if (newPos &#x3D;&#x3D; PagerAdapter.POSITION_UNCHANGED) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (newPos &#x3D;&#x3D; PagerAdapter.POSITION_NONE) &#123;</span><br><span class="line">            mItems.remove(i);</span><br><span class="line">            i--;</span><br><span class="line"></span><br><span class="line">            if (!isUpdating) &#123;</span><br><span class="line">                mAdapter.startUpdate(this);</span><br><span class="line">                isUpdating &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mAdapter.destroyItem(this, ii.position, ii.object);</span><br><span class="line">            needPopulate &#x3D; true;</span><br><span class="line"></span><br><span class="line">            if (mCurItem &#x3D;&#x3D; ii.position) &#123;</span><br><span class="line">                &#x2F;&#x2F; Keep the current item in the valid range</span><br><span class="line">                newCurrItem &#x3D; Math.max(0, Math.min(mCurItem, adapterCount - 1));</span><br><span class="line">                needPopulate &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">		&#x2F;&#x2F;...省略一大堆</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;...省略一大堆</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先会遍历所有缓存，通过 <code>mAdapter.getItemPosition(obj)</code> 判断是否需要销毁重建，该方法默认值 <code>POSITION_UNCHANGED</code> 为-1，即默认数据没有变化。所以我们只需要重写这个方法，确定当前位置的数据是否应该销毁，当然有很多 demo 都是直接建议销毁，即返回 POSITION_NONE。本身 ViewPager 设计并不是为频繁变化的数据，所以数据变化频繁或者为了性能更好，尽可能使用 RecyclerView + PagerSnapHelper 替换 VP。</p>
<h4 id="1-3-重写-adapter-中方法实现刷新"><a href="#1-3-重写-adapter-中方法实现刷新" class="headerlink" title="1.3 重写 adapter 中方法实现刷新"></a>1.3 重写 adapter 中方法实现刷新</h4><p>好，为了继续使用 VP 来更新，应该动态的判断这个 <code>getItemPosition</code>，本身 VP 性能一般，一刀切不适合这种场景，所以我们通过 <code>setTag</code> 来解决这个数据关联问题，如下示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;HashMap&lt;String, String&gt;&gt; data &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">class Adapter extends PagerAdapter &#123;</span><br><span class="line">	&#x2F;&#x2F;...省略其他方法</span><br><span class="line">	@NonNull</span><br><span class="line">    @Override</span><br><span class="line">    public Object instantiateItem(@NonNull ViewGroup container, int position) &#123;</span><br><span class="line">        TextView view &#x3D; (TextView) LayoutInflater.from(ViewPagerActivity.this).inflate(R.layout.layout_simple_text, container, false);</span><br><span class="line">        String text &#x3D; data.get(position).get(&quot;name&quot;);</span><br><span class="line">        view.setText(text);</span><br><span class="line">        view.setTag(-1, position);</span><br><span class="line">        view.setTag(-2, text);</span><br><span class="line">        container.addView(view);</span><br><span class="line">        return view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getItemPosition(@NonNull Object object) &#123;</span><br><span class="line">        if (getCount() &#x3D;&#x3D; 0)</span><br><span class="line">            return POSITION_UNCHANGED;</span><br><span class="line">        View view &#x3D; (View) object;</span><br><span class="line">        int pos &#x3D; (int) view.getTag(-1);</span><br><span class="line">        String msg &#x3D; (String) view.getTag(-2);</span><br><span class="line">        if (pos &gt;&#x3D; getCount()) &#123;</span><br><span class="line">            return POSITION_NONE;</span><br><span class="line">        &#125;</span><br><span class="line">        return msg.equals(data.get(pos).get(&quot;name&quot;)) ? POSITION_UNCHANGED : POSITION_NONE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更改之后效果图：</p>
<p>在判断之后，数据修改之后可以及时反馈到界面上，代价是需要数据源标记原始数据位置，但仅仅是一个4位的int</p>
<p><img src="https://i.loli.net/2020/04/22/OgJVmaLwPqNjShb.gif" alt="vp_2.gif"></p>
<h3 id="2-为什么还要使用-PagerAdapter？"><a href="#2-为什么还要使用-PagerAdapter？" class="headerlink" title="2. 为什么还要使用 PagerAdapter？"></a>2. 为什么还要使用 PagerAdapter？</h3><p>ViewPager 在普通的 View 页面，在今天，使用空间其实很小了，但在 Fragment 组合页面，配合 FragmentPagerAdapter，不得不说非常方便，如果在存在需要动态增减 Fragment，使用 <code>getItemPosition（obj）</code> 来减少创建销毁还是比较合适，当然使用场景是固定几个 fragment （2-3个）配合<code>setOffscreenPageLimit</code>缓存可以一次创建足够，如果有一堆页面（超过设置的缓存数量），这个创建销毁过程的消耗还是客观存在，不容小觑。</p>
<h3 id="3-FragmentPagerAdapter-改造，更适合-Fragment-增减"><a href="#3-FragmentPagerAdapter-改造，更适合-Fragment-增减" class="headerlink" title="3. FragmentPagerAdapter 改造，更适合 Fragment 增减"></a>3. FragmentPagerAdapter 改造，更适合 Fragment 增减</h3><h4 id="3-1-Fragment-创建"><a href="#3-1-Fragment-创建" class="headerlink" title="3.1 Fragment 创建"></a>3.1 Fragment 创建</h4><p>使用 <code>FragmentPagerAdapter</code> 有页面替换需要，除了重写 <code>getItemPosition()</code> 还需要重写 <code>getItemId(position)</code>。为什么？因为 <code>fragment</code> 存在于 <code>FragmentManager</code> 中，通过 <code>mFragmentManager.findFragmentByTag(name)</code> 来找到之前的 fragment，也可以理解为** fragment 的缓存**，具体源码代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiateItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCurTransaction == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mCurTransaction = mFragmentManager.beginTransaction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> itemId = getItemId(position);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do we already have this fragment?</span></span><br><span class="line">    String name = makeFragmentName(container.getId(), itemId);</span><br><span class="line">    Fragment fragment = mFragmentManager.findFragmentByTag(name);</span><br><span class="line">    <span class="keyword">if</span> (fragment != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Attaching item #"</span> + itemId + <span class="string">": f="</span> + fragment);</span><br><span class="line">        mCurTransaction.attach(fragment);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fragment = getItem(position);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Adding item #"</span> + itemId + <span class="string">": f="</span> + fragment);</span><br><span class="line">        mCurTransaction.add(container.getId(), fragment,</span><br><span class="line">                makeFragmentName(container.getId(), itemId));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fragment != mCurrentPrimaryItem) &#123;</span><br><span class="line">        fragment.setMenuVisibility(<span class="keyword">false</span>);</span><br><span class="line">        fragment.setUserVisibleHint(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fragment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有重写该方法，那么，在增减数据后，即使 <code>getItemPosition</code> 判定数据变化，再通过 <code>makeFragmentName(container.getId(), itemId)</code> （itemId 默认是position）获取的 tag 还是不变，那么重新拿到的 fragment 和原来位置的 fragment 一样，，所以必须通过重写 <code>getItemId</code> 来修改 tag，使这数据源中的 fragment 和这个 tag 形成唯一个关联关系，一般唯一性用hashCode就足够了。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Fragment&gt; data = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageAdapter</span> <span class="keyword">extends</span> <span class="title">FragmentPagerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    PageAdapter(FragmentManager fm) &#123;</span><br><span class="line">        <span class="keyword">super</span>(fm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fragment <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        SimpleFragment fragment = (SimpleFragment) data.get(position);</span><br><span class="line">        fragment.setPosition(position);</span><br><span class="line">        <span class="keyword">return</span> fragment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getItemId</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.get(position).hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemPosition</span><span class="params">(@NonNull Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getCount() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> POSITION_UNCHANGED;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> position = ((SimpleFragment) object).getPosition();</span><br><span class="line">        <span class="keyword">if</span> (position &gt;= getCount()) &#123;</span><br><span class="line">            <span class="keyword">return</span> POSITION_NONE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data.get(position).hashCode() == object.hashCode() ? POSITION_UNCHANGED : POSITION_NONE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong> SimpleFragment 只是继承 Fragment 增加一个 position 参数及相应方法。</p>
<h4 id="3-2-适配器修改前后效果图示"><a href="#3-2-适配器修改前后效果图示" class="headerlink" title="3.2 适配器修改前后效果图示"></a>3.2 适配器修改前后效果图示</h4><p>效果图：操作中的删除为 data.remove(1);//删除第二个数据</p>
<p>1.仅修改 getItemPosition</p>
<p><img src="https://i.loli.net/2020/04/22/bAvY6T1UgLHkFEh.gif" alt="vp_3.gif"></p>
<p>2.修改 getItemPosition 和 getItemId</p>
<p><img src="https://i.loli.net/2020/04/22/3K61nlM5RjyPaQF.gif" alt="vp_5.gif"></p>
<p>完。</p>
</div><div class="post-copyright"><blockquote><p>原文作者: ma xiaozhou</p><p>原文链接: <a href="https://maxiaozhou1234.github.io/android/pager-adapter/">https://maxiaozhou1234.github.io/android/pager-adapter/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"><a href="/tags/android/">android</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/android/viewpager-anr/" class="pre">【Android】无限循环ViewPager setCurrentItem 导致 ANR 分析</a><a href="/sqlite/sqlite-test/" class="next">【sqlite】测试题</a></div><div id="comments"><div id="container"><script type="text/javascript" src="https://unpkg.com/gitalk/dist/gitalk.min.js?v=2.0.4"></script><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=2.0.4"></script><script>var gitalk = new Gitalk({
  clientID: 'caaf9fa61b214b649585',
  clientSecret: '99fa000941abd4c7f59a0cce1b1deb26813c4ed1',
  repo: 'maxiaozhou1234.github.io',
  owner: 'maxiaozhou1234',
  admin: ['maxiaozhou1234'],
  id: md5(window.location.pathname),
  distractionFreeMode: false,
  language: 'zh-CN',
  pagerDirection: 'last'
})
gitalk.render('container')</script></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-PagerAdapter-notifyDataSetChange-不刷新问题分析"><span class="toc-text">使用 PagerAdapter notifyDataSetChange 不刷新问题分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-未触发刷新效果及分析"><span class="toc-text">1. 未触发刷新效果及分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-不刷新模拟效果"><span class="toc-text">1.1 不刷新模拟效果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-不刷新源码分析"><span class="toc-text">1.2 不刷新源码分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-重写-adapter-中方法实现刷新"><span class="toc-text">1.3 重写 adapter 中方法实现刷新</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-为什么还要使用-PagerAdapter？"><span class="toc-text">2. 为什么还要使用 PagerAdapter？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-FragmentPagerAdapter-改造，更适合-Fragment-增减"><span class="toc-text">3. FragmentPagerAdapter 改造，更适合 Fragment 增减</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-Fragment-创建"><span class="toc-text">3.1 Fragment 创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-适配器修改前后效果图示"><span class="toc-text">3.2 适配器修改前后效果图示</span></a></li></ol></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/android/java-annotation/">【java】Mapper 自定义注解器</a></li><li class="post-list-item"><a class="post-list-link" href="/android/viewpager-anr/">【Android】无限循环ViewPager setCurrentItem 导致 ANR 分析</a></li><li class="post-list-item"><a class="post-list-link" href="/android/pager-adapter/">【Android】PagerAdapter不刷新问题分析</a></li><li class="post-list-item"><a class="post-list-link" href="/sqlite/sqlite-test/">【sqlite】测试题</a></li><li class="post-list-item"><a class="post-list-link" href="/sqlite/sqlite-view/">【sqlite】VIEW 视图</a></li><li class="post-list-item"><a class="post-list-link" href="/sqlite/sqlite-trigger/">【sqlite】Trigger 触发器</a></li><li class="post-list-item"><a class="post-list-link" href="/sqlite/sqlite-union/">【sqlite】unions 语法笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/sqlite/sqlite-join/">【sqlite】join 语法笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/sqlite/mysql-cmd/">【MySQL】操作命令</a></li><li class="post-list-item"><a class="post-list-link" href="/java/java-nio/">【java】NIO 小结</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/default/">default</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/sqlite/">sqlite</a><span class="category-list-count">6</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/gittalk/" style="font-size: 15px;">gittalk</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/sqlite/" style="font-size: 15px;">sqlite</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/nio/" style="font-size: 15px;">nio</a> <a href="/tags/android/" style="font-size: 15px;">android</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">11</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">ma xiaozhou.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?2329dcd6b360689143bd059b178d5961";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>