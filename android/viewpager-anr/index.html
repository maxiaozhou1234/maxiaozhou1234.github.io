<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="xiaozhou blog"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><link rel="stylesheet" type="text/css" href="https://unpkg.com/gitalk/dist/gitalk.css?v=2.0.4"><title>【Android】无限循环ViewPager setCurrentItem 导致 ANR 分析 | xiaozhou Blog</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">【Android】无限循环ViewPager setCurrentItem 导致 ANR 分析</h1><a id="logo" href="/.">xiaozhou Blog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">【Android】无限循环ViewPager setCurrentItem 导致 ANR 分析</h1><div class="post-meta"><a href="/android/viewpager-anr/#comments" class="comment-count"></a><p><span class="date">Apr 24, 2020</span><span><a href="/categories/android/" class="category">android</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>无限循环 ViewPager setCurrentItem 导致 ANR 分析</p>
<h2 id="1-无限循环-ViewPager"><a href="#1-无限循环-ViewPager" class="headerlink" title="1. 无限循环 ViewPager"></a>1. 无限循环 ViewPager</h2><p>通过 adapter 的 getCount 返回一个足够大的数字，再初始化显示的item在中间位置，那么用户在左右滑动能够模拟出一个循环的显示界面。</p>
<h2 id="2-调用-setCurrentItem-卡顿"><a href="#2-调用-setCurrentItem-卡顿" class="headerlink" title="2. 调用 setCurrentItem 卡顿"></a>2. 调用 setCurrentItem 卡顿</h2><p>当我们设置的 getCount 是一个较小的数字时，调用该方法总能快速跳转到目标位置，但是 getCount 是一个大数，如 Integer.MAX_VALUE，那么在调用跳转时，很容易触发 anr。</p>
<h3 id="2-1-源码分析"><a href="#2-1-源码分析" class="headerlink" title="2.1 源码分析"></a>2.1 源码分析</h3><p>设置显示的item角标，最终调用 <code>void setCurrentItemInternal(int item, boolean smoothScroll, boolean always, int velocity)</code> 这个函数，看下这个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">void setCurrentItemInternal(int item, boolean smoothScroll, boolean always, int velocity) &#123;</span><br><span class="line">    if (mAdapter &#x3D;&#x3D; null || mAdapter.getCount() &lt;&#x3D; 0) &#123;</span><br><span class="line">        setScrollingCacheEnabled(false);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!always &amp;&amp; mCurItem &#x3D;&#x3D; item &amp;&amp; mItems.size() !&#x3D; 0) &#123;</span><br><span class="line">        setScrollingCacheEnabled(false);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (item &lt; 0) &#123;</span><br><span class="line">        item &#x3D; 0;</span><br><span class="line">    &#125; else if (item &gt;&#x3D; mAdapter.getCount()) &#123;</span><br><span class="line">        item &#x3D; mAdapter.getCount() - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    final int pageLimit &#x3D; mOffscreenPageLimit;</span><br><span class="line">	&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">	&#x2F;&#x2F;这个设置是最后铺满画面的判定，但如果是大数，这里就是一个隐藏的 ANR</span><br><span class="line">	&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">    if (item &gt; (mCurItem + pageLimit) || item &lt; (mCurItem - pageLimit)) &#123;</span><br><span class="line">        &#x2F;&#x2F; We are doing a jump by more than one page.  To avoid</span><br><span class="line">        &#x2F;&#x2F; glitches, we want to keep all current pages in the view</span><br><span class="line">        &#x2F;&#x2F; until the scroll ends.</span><br><span class="line">        for (int i &#x3D; 0; i &lt; mItems.size(); i++) &#123;</span><br><span class="line">            mItems.get(i).scrolling &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    final boolean dispatchSelected &#x3D; mCurItem !&#x3D; item;</span><br><span class="line"></span><br><span class="line">    if (mFirstLayout) &#123;</span><br><span class="line">        &#x2F;&#x2F; We don&#39;t have any idea how big we are yet and shouldn&#39;t have any pages either.</span><br><span class="line">        &#x2F;&#x2F; Just set things up and let the pending layout handle things.</span><br><span class="line">        mCurItem &#x3D; item;</span><br><span class="line">        if (dispatchSelected) &#123;</span><br><span class="line">            dispatchOnPageSelected(item);</span><br><span class="line">        &#125;</span><br><span class="line">        requestLayout();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">		&#x2F;&#x2F;重要方法，添加移除item！ANR的分析重点</span><br><span class="line">        populate(item);</span><br><span class="line">		&#x2F;&#x2F;滑动到目标点</span><br><span class="line">        scrollToItem(item, smoothScroll, velocity, dispatchSelected);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面可以看到，首先会先根据当前位置和目标位置距离判断是否需要滑动item，如果是滑动一页，不会触发设置scrolling，假如超过 pageLimit 泽一定会设置 scrolling = true。</p>
<p>第二个方法是 <code>populate(item)</code>，用于移除看不见的item，添加新的item，下面部分代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">void populate(int newCurrentItem) &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;...省略很多代码</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Fill 3x the available width or up to the number of offscreen</span><br><span class="line">    &#x2F;&#x2F; pages requested to either side, whichever is larger.</span><br><span class="line">    &#x2F;&#x2F; If we have no current item we have no work to do.</span><br><span class="line">    if (curItem !&#x3D; null) &#123;</span><br><span class="line">        float extraWidthLeft &#x3D; 0.f;</span><br><span class="line">        int itemIndex &#x3D; curIndex - 1;</span><br><span class="line">        ItemInfo ii &#x3D; itemIndex &gt;&#x3D; 0 ? mItems.get(itemIndex) : null;</span><br><span class="line">        final int clientWidth &#x3D; getClientWidth();</span><br><span class="line">        final float leftWidthNeeded &#x3D; clientWidth &lt;&#x3D; 0 ? 0 :</span><br><span class="line">                2.f - curItem.widthFactor + (float) getPaddingLeft() &#x2F; (float) clientWidth;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">		&#x2F;&#x2F;curIndex 是 mItem 的最后一个item的位置，经过上面处理，已经在原来基础上增加了一个</span><br><span class="line">		&#x2F;&#x2F;ii 是我们现在页面显示的item，这里处理当前页面之前的item是否需要销毁</span><br><span class="line">		&#x2F;&#x2F;这里也很明显看出运算次数为 pos 次，当设置是一个大数是，2^32 ≈ 8^10 约等于 10^10</span><br><span class="line">		&#x2F;&#x2F;那么这里将执行总数的一半次数，估计 10^9 次</span><br><span class="line">		&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">        for (int pos &#x3D; mCurItem - 1; pos &gt;&#x3D; 0; pos--) &#123;</span><br><span class="line">            if (extraWidthLeft &gt;&#x3D; leftWidthNeeded &amp;&amp; pos &lt; startPos) &#123;</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F;当 ii 为null时，能够跳出循环，ii的更新在下面的判断块中</span><br><span class="line">                if (ii &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F;只有条件成立才会更新ii，但上面说到，如果更新的位置在pageLimit之内，</span><br><span class="line">				&#x2F;&#x2F;scrolling 为false，超出则是true，超出的时候为了保证界面能完全填充</span><br><span class="line">				&#x2F;&#x2F;也就是说无法跳出循环，所以在大数的时候，这里才是导致 ANR 的根本原因</span><br><span class="line">                if (pos &#x3D;&#x3D; ii.position &amp;&amp; !ii.scrolling) &#123;</span><br><span class="line">                    mItems.remove(itemIndex);</span><br><span class="line">                    mAdapter.destroyItem(this, pos, ii.object);</span><br><span class="line">                    if (DEBUG) &#123;</span><br><span class="line">                        Log.i(TAG, &quot;populate() - destroyItem() with pos: &quot; + pos</span><br><span class="line">                                + &quot; view: &quot; + ((View) ii.object));</span><br><span class="line">                    &#125;</span><br><span class="line">                    itemIndex--;</span><br><span class="line">                    curIndex--;</span><br><span class="line">                    ii &#x3D; itemIndex &gt;&#x3D; 0 ? mItems.get(itemIndex) : null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (ii !&#x3D; null &amp;&amp; pos &#x3D;&#x3D; ii.position) &#123;</span><br><span class="line">                extraWidthLeft +&#x3D; ii.widthFactor;</span><br><span class="line">                itemIndex--;</span><br><span class="line">                ii &#x3D; itemIndex &gt;&#x3D; 0 ? mItems.get(itemIndex) : null;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ii &#x3D; addNewItem(pos, itemIndex + 1);</span><br><span class="line">                extraWidthLeft +&#x3D; ii.widthFactor;</span><br><span class="line">                curIndex++;</span><br><span class="line">                ii &#x3D; itemIndex &gt;&#x3D; 0 ? mItems.get(itemIndex) : null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        float extraWidthRight &#x3D; curItem.widthFactor;</span><br><span class="line">        itemIndex &#x3D; curIndex + 1;</span><br><span class="line">        if (extraWidthRight &lt; 2.f) &#123;</span><br><span class="line">            ii &#x3D; itemIndex &lt; mItems.size() ? mItems.get(itemIndex) : null;</span><br><span class="line">            final float rightWidthNeeded &#x3D; clientWidth &lt;&#x3D; 0 ? 0 :</span><br><span class="line">                    (float) getPaddingRight() &#x2F; (float) clientWidth + 2.f;</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F;这里同理，上面是判断设置的新页面在右边时，对当前页的左边进行处理</span><br><span class="line">			&#x2F;&#x2F;下面代码是对当前页面右边的处理，一般执行次数为 pageLimit</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F;如果新页面位置在当前页的右边，下面只会执行 pageLimit 次就跳出循环，因为pos+pageLimit 后的ii是null</span><br><span class="line">			&#x2F;&#x2F;同理，如果新页面在当前页的左边，上面也只会执行1次就跳出，因为 pos-pageLimit 的ii是null</span><br><span class="line">            for (int pos &#x3D; mCurItem + 1; pos &lt; N; pos++) &#123;</span><br><span class="line">                if (extraWidthRight &gt;&#x3D; rightWidthNeeded &amp;&amp; pos &gt; endPos) &#123;</span><br><span class="line">                    if (ii &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (pos &#x3D;&#x3D; ii.position &amp;&amp; !ii.scrolling) &#123;</span><br><span class="line">                        mItems.remove(itemIndex);</span><br><span class="line">                        mAdapter.destroyItem(this, pos, ii.object);</span><br><span class="line">                        if (DEBUG) &#123;</span><br><span class="line">                            Log.i(TAG, &quot;populate() - destroyItem() with pos: &quot; + pos</span><br><span class="line">                                    + &quot; view: &quot; + ((View) ii.object));</span><br><span class="line">                        &#125;</span><br><span class="line">                        ii &#x3D; itemIndex &lt; mItems.size() ? mItems.get(itemIndex) : null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (ii !&#x3D; null &amp;&amp; pos &#x3D;&#x3D; ii.position) &#123;</span><br><span class="line">                    extraWidthRight +&#x3D; ii.widthFactor;</span><br><span class="line">                    itemIndex++;</span><br><span class="line">                    ii &#x3D; itemIndex &lt; mItems.size() ? mItems.get(itemIndex) : null;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    ii &#x3D; addNewItem(pos, itemIndex);</span><br><span class="line">                    itemIndex++;</span><br><span class="line">                    extraWidthRight +&#x3D; ii.widthFactor;</span><br><span class="line">                    ii &#x3D; itemIndex &lt; mItems.size() ? mItems.get(itemIndex) : null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        calculatePageOffsets(curItem, curIndex, oldCurInfo);</span><br><span class="line"></span><br><span class="line">        mAdapter.setPrimaryItem(this, mCurItem, curItem.object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;...省略很多代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面注释说明非常清楚，通过对 <strong>pos</strong>和<strong>scrolling</strong>判断，来决定是否销毁当前页的前/后数据，这里程序只会循环 currentItem 次，原本我猜测即使空转，那应该也会很快处理完成，但在大数面前，任何的空转都应当理性对待。</p>
<p>假设 1w 次循环耗时为0.04ms，那么被放大10^5，也会达到4s，当设置为大数时，这个循环的时间不可忽视。</p>
<p>为了更加严谨，我在<code>void populate(int newCurrentItem)</code> 前后加入时间埋点，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">public class AspectVp &#123;</span><br><span class="line">    private long time &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    @Before(&quot;call(void populate(..))&quot;)</span><br><span class="line">    public void beforePopulate(JoinPoint joinPoint) &#123;</span><br><span class="line">        if (joinPoint.getArgs().length &gt; 0) &#123;</span><br><span class="line">            Log.d(&quot;zhou&quot;, &quot;AspectVp [before populate &gt;&gt; &quot; + (time &#x3D; System.currentTimeMillis()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @After(&quot;call(void populate(..))&quot;)</span><br><span class="line">    public void afterPopulate(JoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">        if (joinPoint.getArgs().length &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">            long t &#x3D; System.currentTimeMillis();</span><br><span class="line">            Log.i(&quot;zhou&quot;, &quot;AspectVp [after  populate &gt;&gt; &quot; + t + &quot; &#x3D;&#x3D;&#x3D; spend &#x3D; &quot;</span><br><span class="line">                    + (t - time) + &quot; ms&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当设置个数为 20000，当前页为10000，跳转到 cur+10 位置，单次执行耗时 11<del>27 ms，如图1所示；<br>当设置个数为 2^32，当前页为 2^31 ，跳转到 cur+10 位置，单次执行耗时 3267</del>4193 ms，如图2所示：</p>
<p>图1：个数 20000</p>
<p><img src="https://i.loli.net/2020/04/24/WyOU1dhil7qBV2D.gif" alt="vp_small.gif"></p>
<p>图2：个数 2^32</p>
<p><img src="https://i.loli.net/2020/04/24/gyZ17rxLIFK9Hdn.gif" alt="vp_big.gif"></p>
<p>而且，从日志也可以看出，一次超缓存数的跳转，会触发四次 <code>populate(item)</code> 的调用。</p>
<p>1.setCurrentItem -&gt;  触发 populate(item)<br>2.populate(item) 有新item加入 -&gt; 触发 onMeasure -&gt; populate()<br>3.populate() -&gt; populate(item)<br>   | — 有可能再次判定加入新 item，跳转2，但下一次肯定不会有新的item需要添加<br>   | — 没有新增的 item<br>4.最后滑动结束，发出一个 populate() 保证页面覆盖完全</p>
<p>所以，3再会触发一次 <code>populate()</code>，但3-2-3不会成为死循环，总共有4次调用</p>
<h3 id="2-2-解决思路"><a href="#2-2-解决思路" class="headerlink" title="2.2 解决思路"></a>2.2 解决思路</h3><p>处理这个问题，有简单的方法，因为设置大数 2^32 真的太大了，修改为小一点、用户感知不强的数字，如10000,而5千次的滑动对用户也算是大操作，并且这个循环耗时在一个可接受范围，也不会造成页面的卡顿甚至 ANR。</p>
<p>或者，当设置的item超过pageLimit，我们强制把 isSrolling 设置为false，那么在遍历缓存 mItem 时能够及时更新 ii，使我们及时打破循环，跳出无用的循环时间。</p>
<h2 id="3-具体方案：打破循环"><a href="#3-具体方案：打破循环" class="headerlink" title="3. 具体方案：打破循环"></a>3. 具体方案：打破循环</h2><p>打破循环，让 <code>for (int pos = mCurItem - 1; pos &gt;= 0; pos--)</code> 和 <code>for (int pos = mCurItem + 1; pos &lt; N; pos++)</code> 尽快结束循环</p>
<h3 id="3-1-设置有限的小数（相对-2-32-来说）"><a href="#3-1-设置有限的小数（相对-2-32-来说）" class="headerlink" title="3.1 设置有限的小数（相对 2^32 来说）"></a>3.1 设置有限的小数（相对 2^32 来说）</h3><p>adapter 设置 getCount 为小数值，让循环基数降低，即使执行次数多，所等待的时间也处于可接受范围</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Adapter extends PagerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;...省略其他代码</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getCount() &#123;</span><br><span class="line">        return 10000;&#x2F;&#x2F;自行设置一个合理的数值</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;...省略其他代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-不触发设置-scrolling-条件"><a href="#3-2-不触发设置-scrolling-条件" class="headerlink" title="3.2 不触发设置 scrolling 条件"></a>3.2 不触发设置 scrolling 条件</h3><p>在 setCurrentItem 后，只要设置的 newIndex 在区间 <strong>(currentItem-pageLimit,currentItem+pageLimit)</strong>，就不会触发设置该条件，那么在调用设置之前，把 pageLimit 设置为 <strong>Math.abs(newIndex - currentItem)</strong>，调用设置位置之后，再重置回去，同样可以达到秒跳转效果，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;原调用 viewPager.setCurrentItem(newIndex, true); 修改如下</span><br><span class="line"></span><br><span class="line">int tmp &#x3D; viewPager.getOffscreenPageLimit();</span><br><span class="line">int newIndex &#x3D; viewPager.getCurrentItem() + 10;</span><br><span class="line">            </span><br><span class="line">int newLimit &#x3D; Math.abs(newIndex-viewPager.getCurrentItem());</span><br><span class="line">if(newLimit&gt;tmp) &#123;</span><br><span class="line">    viewPager.setOffscreenPageLimit(newLimit);</span><br><span class="line">    viewPager.setCurrentItem(newIndex, true);</span><br><span class="line">    viewPager.setOffscreenPageLimit(tmp);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    viewPager.setCurrentItem(newIndex, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-重置-scrolling-为-false"><a href="#3-3-重置-scrolling-为-false" class="headerlink" title="3.3 重置 scrolling 为 false"></a>3.3 重置 scrolling 为 false</h3><p>在设置完 setCurrentItem 后，由于跳转距离问题会将 scrolling 置为 true，所以在执行 <code>void populate(int newCurrentItem)</code> 之前把 scrolling 重置为 false，但是 mItems 是私有变量，需通过反射获取，再通过 AspectJ 埋点在执行之前遍历重置 scrolling，这么看来，无疑方法二是最快解决问题的方式。</p>
<p>以下代码仅供参考，请不要随意应用于生产环境，确定使用请仔细评估性能消耗，完成覆盖测试</p>
<p><strong>！注意：这里的注入对象是所有的 ViewPager！！</strong></p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">public class AspectVp &#123;</span><br><span class="line">    private long time &#x3D; 0;</span><br><span class="line">    private static ArrayList&lt;Object&gt; items &#x3D; null;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;反射获取</span><br><span class="line">    public static void setupViewPager(ViewPager viewPager) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Field field &#x3D; viewPager.getClass().getDeclaredField(&quot;mItems&quot;);</span><br><span class="line">            field.setAccessible(true);</span><br><span class="line">            items &#x3D; (ArrayList&lt;Object&gt;) field.get(viewPager);</span><br><span class="line">        &#125; catch (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(&quot;zhou&quot;, &quot;setupViewPager &quot; + (items &#x3D;&#x3D; null ? &quot;null&quot; : items.size()));</span><br><span class="line">    &#125;</span><br><span class="line">	&#x2F;&#x2F;及时销毁</span><br><span class="line">    public static void destroyItems() &#123;</span><br><span class="line">        items &#x3D; null;</span><br><span class="line">        Log.i(&quot;zhou&quot;, &quot;destroyItems &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Before(&quot;call(void populate(..))&quot;)</span><br><span class="line">    public void beforePopulate(JoinPoint joinPoint) &#123;</span><br><span class="line">        if (joinPoint.getArgs().length &gt; 0) &#123;</span><br><span class="line">            Log.d(&quot;zhou&quot;, &quot;AspectVp [before populate &gt;&gt; &quot; + (time &#x3D; System.currentTimeMillis()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @After(&quot;call(void populate(..))&quot;)</span><br><span class="line">    public void afterPopulate(JoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">        if (joinPoint.getArgs().length &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">            long t &#x3D; System.currentTimeMillis();</span><br><span class="line">            Log.i(&quot;zhou&quot;, &quot;AspectVp [after  populate &gt;&gt; &quot; + t + &quot; &#x3D;&#x3D;&#x3D; spend &#x3D; &quot;</span><br><span class="line">                    + (t - time) + &quot; ms&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Before(&quot;execution(void populate(..))&quot;)</span><br><span class="line">    public void executionBefore(JoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">        if (joinPoint.getArgs().length &gt; 0 &amp;&amp; items !&#x3D; null) &#123;</span><br><span class="line">            for (Object obj : items) &#123;&#x2F;&#x2F;强制重置为false</span><br><span class="line">                Field scrolling &#x3D; obj.getClass().getDeclaredField(&quot;scrolling&quot;);</span><br><span class="line">                scrolling.setAccessible(true);</span><br><span class="line">                scrolling.set(obj, false);</span><br><span class="line">            &#125;</span><br><span class="line">            Log.i(&quot;zhou&quot;, &quot;executionBefore [&quot; + items.size() + &quot;]&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调用</span><br><span class="line">class MainActivity extent Activity&#123;</span><br><span class="line"></span><br><span class="line">	 @Override</span><br><span class="line">	protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">	    super.onCreate(savedInstanceState);</span><br><span class="line">		&#x2F;&#x2F;省略其他</span><br><span class="line">		</span><br><span class="line">	        AspectVp.setupViewPager(viewPager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onStop() &#123;</span><br><span class="line">        super.onStop();</span><br><span class="line">		&#x2F;&#x2F;销毁</span><br><span class="line">        AspectVp.destroyItems();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果如下：</p>
<p><img src="https://i.loli.net/2020/04/24/gUDyE1jeSn6OsoQ.gif" alt="vp_asept.gif"></p>
<p>完。</p>
</div><div class="post-copyright"><blockquote><p>原文作者: ma xiaozhou</p><p>原文链接: <a href="https://maxiaozhou1234.github.io/android/viewpager-anr/">https://maxiaozhou1234.github.io/android/viewpager-anr/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"><a href="/tags/android/">android</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/android/java-annotation/" class="pre">【java】Mapper 自定义注解器</a><a href="/android/pager-adapter/" class="next">【Android】PagerAdapter不刷新问题分析</a></div><div id="comments"><div id="container"><script type="text/javascript" src="https://unpkg.com/gitalk/dist/gitalk.min.js?v=2.0.4"></script><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=2.0.4"></script><script>var gitalk = new Gitalk({
  clientID: 'caaf9fa61b214b649585',
  clientSecret: '99fa000941abd4c7f59a0cce1b1deb26813c4ed1',
  repo: 'maxiaozhou1234.github.io',
  owner: 'maxiaozhou1234',
  admin: ['maxiaozhou1234'],
  id: md5(window.location.pathname),
  distractionFreeMode: false,
  language: 'zh-CN',
  pagerDirection: 'last'
})
gitalk.render('container')</script></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-无限循环-ViewPager"><span class="toc-text">1. 无限循环 ViewPager</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-调用-setCurrentItem-卡顿"><span class="toc-text">2. 调用 setCurrentItem 卡顿</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-源码分析"><span class="toc-text">2.1 源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-解决思路"><span class="toc-text">2.2 解决思路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-具体方案：打破循环"><span class="toc-text">3. 具体方案：打破循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-设置有限的小数（相对-2-32-来说）"><span class="toc-text">3.1 设置有限的小数（相对 2^32 来说）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-不触发设置-scrolling-条件"><span class="toc-text">3.2 不触发设置 scrolling 条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-重置-scrolling-为-false"><span class="toc-text">3.3 重置 scrolling 为 false</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/vue/vue-%E5%88%9D%E5%AD%A6%E9%97%AE%E9%A2%98%E5%B0%8F%E8%AE%B0/">【vue】 vue 初学问题小记</a></li><li class="post-list-item"><a class="post-list-link" href="/java/java-generic/">【java】泛型理解：协变、逆变、不变</a></li><li class="post-list-item"><a class="post-list-link" href="/default/note-of-computer/">【note】计算机组成原理总结</a></li><li class="post-list-item"><a class="post-list-link" href="/java/java-pipe/">【java】Pipe</a></li><li class="post-list-item"><a class="post-list-link" href="/android/java-annotation/">【java】Mapper 自定义注解器</a></li><li class="post-list-item"><a class="post-list-link" href="/android/viewpager-anr/">【Android】无限循环ViewPager setCurrentItem 导致 ANR 分析</a></li><li class="post-list-item"><a class="post-list-link" href="/android/pager-adapter/">【Android】PagerAdapter不刷新问题分析</a></li><li class="post-list-item"><a class="post-list-link" href="/sqlite/sqlite-test/">【sqlite】测试题</a></li><li class="post-list-item"><a class="post-list-link" href="/sqlite/sqlite-view/">【sqlite】VIEW 视图</a></li><li class="post-list-item"><a class="post-list-link" href="/sqlite/sqlite-trigger/">【sqlite】Trigger 触发器</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/default/">default</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/sqlite/">sqlite</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/vue/">vue</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/gittalk/" style="font-size: 15px;">gittalk</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/sqlite/" style="font-size: 15px;">sqlite</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/nio/" style="font-size: 15px;">nio</a> <a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" style="font-size: 15px;">计算机</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">11</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">ma xiaozhou.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?2329dcd6b360689143bd059b178d5961";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>