[{"title":"【Android】PagerAdapter不刷新问题分析","date":"2020-04-22T14:50:10.000Z","path":"android/pager-adapter/","text":"使用 PagerAdapter notifyDataSetChange 不刷新问题分析无论是普通的 ViewPager 视图，还是用 Fragment，当我们刷新数据后调用 notifyDataSetChange 后，往往会发现当前界面并没有预想的触发刷新，根本原因在于 ViewPager 的缓存机制判定数据未发生变化，从而不触发刷新，及时数据确实发生了改变。 1. 未触发刷新效果及分析假设当前 page 是第一页，第一个数据发生变更，此时调用 notifyDataSetChange 后页面并没有变化，原因在于当前页面没有触发强制刷新，仅仅是从缓存中取数据而已。 1.1 不刷新模拟效果ViewPager 默认缓存数是1，即当前页+缓存，总共2，从效果图也可以看出更新数据后，当前页和滑动一页并不会销毁改页，在两页之后回到第一页，之前的页才被销毁，重新创建。 此页面有三个 view 在 ViewPager 中，当点击按钮会更新第一个 view 中的文字，在没有重写 getItemPosition 下，效果如下所示 1.2 不刷新源码分析当然，我们可以从 ViewPager 中看到，当我们调用 notifyDataSetChange 后会回调 VP 的 void dataSetChanged()，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142void dataSetChanged() &#123; &#x2F;&#x2F; This method only gets called if our observer is attached, so mAdapter is non-null. final int adapterCount &#x3D; mAdapter.getCount(); mExpectedAdapterCount &#x3D; adapterCount; boolean needPopulate &#x3D; mItems.size() &lt; mOffscreenPageLimit * 2 + 1 &amp;&amp; mItems.size() &lt; adapterCount; int newCurrItem &#x3D; mCurItem; boolean isUpdating &#x3D; false; for (int i &#x3D; 0; i &lt; mItems.size(); i++) &#123; final ItemInfo ii &#x3D; mItems.get(i); &#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;核心方法&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; final int newPos &#x3D; mAdapter.getItemPosition(ii.object); if (newPos &#x3D;&#x3D; PagerAdapter.POSITION_UNCHANGED) &#123; continue; &#125; if (newPos &#x3D;&#x3D; PagerAdapter.POSITION_NONE) &#123; mItems.remove(i); i--; if (!isUpdating) &#123; mAdapter.startUpdate(this); isUpdating &#x3D; true; &#125; mAdapter.destroyItem(this, ii.position, ii.object); needPopulate &#x3D; true; if (mCurItem &#x3D;&#x3D; ii.position) &#123; &#x2F;&#x2F; Keep the current item in the valid range newCurrItem &#x3D; Math.max(0, Math.min(mCurItem, adapterCount - 1)); needPopulate &#x3D; true; &#125; continue; &#125; &#x2F;&#x2F;...省略一大堆 &#125; &#x2F;&#x2F;...省略一大堆&#125; 首先会遍历所有缓存，通过 mAdapter.getItemPosition(obj) 判断是否需要销毁重建，该方法默认值 POSITION_UNCHANGED 为-1，即默认数据没有变化。所以我们只需要重写这个方法，确定当前位置的数据是否应该销毁，当然有很多 demo 都是直接建议销毁，即返回 POSITION_NONE。本身 ViewPager 设计并不是为频繁变化的数据，所以数据变化频繁或者为了性能更好，尽可能使用 RecyclerView + PagerSnapHelper 替换 VP。 1.3 重写 adapter 中方法实现刷新好，为了继续使用 VP 来更新，应该动态的判断这个 getItemPosition，本身 VP 性能一般，一刀切不适合这种场景，所以我们通过 setTag 来解决这个数据关联问题，如下示例： 1234567891011121314151617181920212223242526272829private List&lt;HashMap&lt;String, String&gt;&gt; data &#x3D; new ArrayList&lt;&gt;();class Adapter extends PagerAdapter &#123; &#x2F;&#x2F;...省略其他方法 @NonNull @Override public Object instantiateItem(@NonNull ViewGroup container, int position) &#123; TextView view &#x3D; (TextView) LayoutInflater.from(ViewPagerActivity.this).inflate(R.layout.layout_simple_text, container, false); String text &#x3D; data.get(position).get(&quot;name&quot;); view.setText(text); view.setTag(-1, position); view.setTag(-2, text); container.addView(view); return view; &#125; @Override public int getItemPosition(@NonNull Object object) &#123; if (getCount() &#x3D;&#x3D; 0) return POSITION_UNCHANGED; View view &#x3D; (View) object; int pos &#x3D; (int) view.getTag(-1); String msg &#x3D; (String) view.getTag(-2); if (pos &gt;&#x3D; getCount()) &#123; return POSITION_NONE; &#125; return msg.equals(data.get(pos).get(&quot;name&quot;)) ? POSITION_UNCHANGED : POSITION_NONE; &#125;&#125; 更改之后效果图： 在判断之后，数据修改之后可以及时反馈到界面上，代价是需要数据源标记原始数据位置，但仅仅是一个4位的int 2. 为什么还要使用 PagerAdapter？ViewPager 在普通的 View 页面，在今天，使用空间其实很小了，但在 Fragment 组合页面，配合 FragmentPagerAdapter，不得不说非常方便，如果在存在需要动态增减 Fragment，使用 getItemPosition（obj） 来减少创建销毁还是比较合适，当然使用场景是固定几个 fragment （2-3个）配合setOffscreenPageLimit缓存可以一次创建足够，如果有一堆页面（超过设置的缓存数量），这个创建销毁过程的消耗还是客观存在，不容小觑。 3. FragmentPagerAdapter 改造，更适合 Fragment 增减3.1 Fragment 创建使用 FragmentPagerAdapter 有页面替换需要，除了重写 getItemPosition() 还需要重写 getItemId(position)。为什么？因为 fragment 存在于 FragmentManager 中，通过 mFragmentManager.findFragmentByTag(name) 来找到之前的 fragment，也可以理解为** fragment 的缓存**，具体源码代码如下： 123456789101112131415161718192021222324252627@Overridepublic Object instantiateItem(ViewGroup container, int position) &#123; if (mCurTransaction == null) &#123; mCurTransaction = mFragmentManager.beginTransaction(); &#125; final long itemId = getItemId(position); // Do we already have this fragment? String name = makeFragmentName(container.getId(), itemId); Fragment fragment = mFragmentManager.findFragmentByTag(name); if (fragment != null) &#123; if (DEBUG) Log.v(TAG, \"Attaching item #\" + itemId + \": f=\" + fragment); mCurTransaction.attach(fragment); &#125; else &#123; fragment = getItem(position); if (DEBUG) Log.v(TAG, \"Adding item #\" + itemId + \": f=\" + fragment); mCurTransaction.add(container.getId(), fragment, makeFragmentName(container.getId(), itemId)); &#125; if (fragment != mCurrentPrimaryItem) &#123; fragment.setMenuVisibility(false); fragment.setUserVisibleHint(false); &#125; return fragment;&#125; 如果没有重写该方法，那么，在增减数据后，即使 getItemPosition 判定数据变化，再通过 makeFragmentName(container.getId(), itemId) （itemId 默认是position）获取的 tag 还是不变，那么重新拿到的 fragment 和原来位置的 fragment 一样，，所以必须通过重写 getItemId 来修改 tag，使这数据源中的 fragment 和这个 tag 形成唯一个关联关系，一般唯一性用hashCode就足够了。示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738private List&lt;Fragment&gt; data = new ArrayList&lt;&gt;();class PageAdapter extends FragmentPagerAdapter &#123; PageAdapter(FragmentManager fm) &#123; super(fm); &#125; @Override public Fragment getItem(int position) &#123; SimpleFragment fragment = (SimpleFragment) data.get(position); fragment.setPosition(position); return fragment; &#125; @Override public int getCount() &#123; return data.size(); &#125; @Override public long getItemId(int position) &#123; return data.get(position).hashCode(); &#125; @Override public int getItemPosition(@NonNull Object object) &#123; if (getCount() == 0) return POSITION_UNCHANGED; int position = ((SimpleFragment) object).getPosition(); if (position &gt;= getCount()) &#123; return POSITION_NONE; &#125; return data.get(position).hashCode() == object.hashCode() ? POSITION_UNCHANGED : POSITION_NONE; &#125;&#125; 注： SimpleFragment 只是继承 Fragment 增加一个 position 参数及相应方法。 3.2 适配器修改前后效果图示效果图：操作中的删除为 data.remove(1);//删除第二个数据 1.仅修改 getItemPosition 2.修改 getItemPosition 和 getItemId 完。","tags":[{"name":"android","slug":"android","permalink":"https://maxiaozhou1234.github.io/tags/android/"}]},{"title":"【sqlite】测试题","date":"2020-02-26T06:54:21.000Z","path":"sqlite/sqlite-test/","text":"数据库测试题 数据库测试，写出对应的操作 sql 语句1.筛选出表A和表B中列【id,name,age】去重后合并输出合并选择 union/union all 去重 union前提两个表均包含列【id,name,age】 select id,name,age from table_A union select id,name,age from table_B; 2.表1和表2存在id关联关系，将两表列相关联数据全部输出 存在关联，明显是用 join 对于单表都有扩展的列，可以用 outer join，inner join 只要相关联数据，说明是两表都有的数据，使用 inner join。使用 outer join 输出会把缺少的补位 null，属于全量。 123456789101112131415mysql&gt; select * from company;+----+-------+------+------------+--------+| id | name | age | address | salary |+----+-------+------+------------+--------+| 1 | Paul | 32 | California | 20000 || 2 | Allen | 25 | Texas | 15000 || 3 | Teddy | 23 | Norway | 20000 || 4 | Mark | 25 | Rich-Mond | 65000 || 5 | David | 27 | Texas | 85000 || 6 | Kim | 22 | South-Hall | 45000 || 7 | James | 24 | Houston | 10000 || 8 | Kit | 30 | NY | 12000 || 10 | Mike | 17 | NY | 2000 |+----+-------+------+------------+--------+9 rows in set (0.00 sec) 12345678910111213mysql&gt; select * from department;+----+-------------+--------+| id | dept | emp_id |+----+-------------+--------+| 1 | IT Billing | 1 || 2 | Engineering | 2 || 3 | Finance | 7 || 4 | Engineering | 3 || 5 | Finance | 4 || 6 | Engineering | 5 || 7 | Finance | 6 |+----+-------------+--------+7 rows in set (0.00 sec) 使用 inner join 输出： mysql&gt; select c.id,c.name,c.salary,d.dept from company c inner join department d on c.id=d.emp_id; 123456789101112+----+-------+--------+-------------+| id | name | salary | dept |+----+-------+--------+-------------+| 1 | Paul | 20000 | IT Billing || 2 | Allen | 15000 | Engineering || 7 | James | 10000 | Finance || 3 | Teddy | 20000 | Engineering || 4 | Mark | 65000 | Finance || 5 | David | 85000 | Engineering || 6 | Kim | 45000 | Finance |+----+-------+--------+-------------+7 rows in set (0.00 sec) 对比外连接1.使用 company 左外连接 department mysql&gt; select c.id,c.name,c.salary,d.dept from company c left outer join department d on c.id=d.emp_id; 1234567891011121314+----+-------+--------+-------------+| id | name | salary | dept |+----+-------+--------+-------------+| 1 | Paul | 20000 | IT Billing || 2 | Allen | 15000 | Engineering || 3 | Teddy | 20000 | Engineering || 4 | Mark | 65000 | Finance || 5 | David | 85000 | Engineering || 6 | Kim | 45000 | Finance || 7 | James | 10000 | Finance || 8 | Kit | 12000 | NULL || 10 | Mike | 2000 | NULL |+----+-------+--------+-------------+9 rows in set (0.00 sec) 2.使用 company 右外连接 department （sqlite不支持右外连接可以使用左外连接，调整两个表位置） mysql&gt; select c.id,c.name,c.salary,d.dept from company c right outer join department d on c.id=d.emp_id; 123456789101112+------+-------+--------+-------------+| id | name | salary | dept |+------+-------+--------+-------------+| 1 | Paul | 20000 | IT Billing || 2 | Allen | 15000 | Engineering || 7 | James | 10000 | Finance || 3 | Teddy | 20000 | Engineering || 4 | Mark | 65000 | Finance || 5 | David | 85000 | Engineering || 6 | Kim | 45000 | Finance |+------+-------+--------+-------------+7 rows in set (0.00 sec) 上面可以看到，外连接输出与左表、右表相关，题目只要相关联，使用inner join。 3.表1和表2彼此独立，请列出两表的所有可能组合交叉连接select * from table_1 cross join table_2; 4.表1为员工表，manager_id 为该员工领导id，请通过单表列出员工的[id,name,manager_name]mysql&gt; desc employ; 123456789+------------+----------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+------------+----------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || name | char(20) | YES | | NULL | || salary | double | YES | | NULL | || manager_id | int(11) | YES | | NULL | |+------------+----------+------+-----+---------+-------+4 rows in set (0.01 sec) mysql&gt; select * from employ; 1234567891011+------+------+--------+------------+| id | name | salary | manager_id |+------+------+--------+------------+| 1 | aa | 2000 | 3 || 2 | bb | 1000 | 3 || 3 | cc | 2500 | 4 || 4 | dd | 6000 | 100 || 100 | ee | 6000 | 0 || 5 | vv | 3000 | 100 |+------+------+--------+------------+6 rows in set (0.00 sec) mysql&gt; select e.id,e.name,e2.name as manager_name from employ e,employ e2 where e.manager_id=e2.id; 12345678910+------+------+--------------+| id | name | manager_name |+------+------+--------------+| 1 | aa | cc || 2 | bb | cc || 3 | cc | dd || 4 | dd | ee || 5 | vv | ee |+------+------+--------------+5 rows in set (0.00 sec) 5.触发器，表1是用户数据表，uid是操作者id（假设是运维管理），id是新增用户id，需要把表1的增删改操作记录到表log中[uid操作者,action动作,id被操作对象,date时间]表1：create table user (id int primary key auto_increment,name char(20),age int check(age&gt;0),uid int); mysql&gt; desc user; 123456789+-------+----------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+----------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || name | char(20) | YES | | NULL | || age | int(11) | YES | | NULL | || uid | int(11) | YES | | NULL | |+-------+----------+------+-----+---------+----------------+4 rows in set (0.01 sec) 表2：create table user_log (uid int,action char(20),id int,time timestamp default CURRENT_TIMESTAMP); mysql&gt; desc user_log; 123456789+--------+-----------+------+-----+-------------------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-----------+------+-----+-------------------+-------+| uid | int(11) | YES | | NULL | || action | char(20) | YES | | NULL | || id | int(11) | YES | | NULL | || time | timestamp | NO | | CURRENT_TIMESTAMP | |+--------+-----------+------+-----+-------------------+-------+4 rows in set (0.01 sec) 创建触发器。由于 MySQL 5.5只支持单事件触发，所以需要三个对应触发器 增 mysql&gt; create trigger user_insert after insert on user -&gt; for each row -&gt; BEGIN -&gt; insert into user_log(uid,action,id) values (new.uid,’create’,new.id); -&gt; END; -&gt; //Query OK, 0 rows affected (0.06 sec) 改 mysql&gt; create trigger user_update after update on user -&gt; for each row -&gt; BEGIN -&gt; insert into user_log(uid,action,id) values (old.uid,’update’,old.id); -&gt; END; -&gt; //Query OK, 0 rows affected (0.05 sec) 删 mysql&gt; create trigger user_delete after delete on user -&gt; for each row -&gt; BEGIN -&gt; insert into user_log(uid,action,id) values (old.uid,’delete’,old.id); -&gt; END; -&gt; //Query OK, 0 rows affected (0.08 sec) 测试： mysql&gt; select * from user; Empty set (0.00 sec) mysql&gt; select * from user_log; Empty set (0.00 sec) mysql&gt; insert into user (uid,name,age)values (1000,&apos;aka&apos;,10); Query OK, 1 row affected (0.03 sec) mysql&gt; insert into user (uid,name,age)values (1000,&apos;mille&apos;,19); Query OK, 1 row affected (0.03 sec) mysql&gt; insert into user (uid,name,age)values (1003,&apos;jim&apos;,22); Query OK, 1 row affected (0.03 sec) mysql&gt; update user set name=&apos;Sare&apos; where id=&apos;1&apos;; Query OK, 1 row affected (0.02 sec) Rows matched: 1 Changed: 1 Warnings: 0 mysql&gt; delete from user where id=2; Query OK, 1 row affected (0.03 sec)结果显示：mysql&gt; select * from user; 1234567+----+-------+------+------+| id | name | age | uid |+----+-------+------+------+| 1 | Sare | 10 | 1000 || 3 | jim | 22 | 1003 |+----+-------+------+------+2 rows in set (0.00 sec) mysql&gt; select * from user_log; 12345678910+------+--------+------+---------------------+| uid | action | id | time |+------+--------+------+---------------------+| 1000 | create | 1 | 2020-02-26 10:59:26 || 1000 | create | 2 | 2020-02-26 10:59:43 || 1003 | create | 3 | 2020-02-26 11:00:12 || 1000 | update | 1 | 2020-02-26 11:01:02 || 1000 | delete | 2 | 2020-02-26 11:01:39 |+------+--------+------+---------------------+5 rows in set (0.00 sec)","tags":[{"name":"sqlite","slug":"sqlite","permalink":"https://maxiaozhou1234.github.io/tags/sqlite/"}]},{"title":"【sqlite】VIEW 视图","date":"2020-02-25T10:08:50.000Z","path":"sqlite/sqlite-view/","text":"sqlite view 视图 View 视图视图（View）可以包含一个表的所有行或从一个或多个表选定行。视图（View）可以从一个或多个表创建，这取决于要创建视图的 SQLite 查询。 1.创建视图语法 CREATE [TEMP | TEMPORARY] VIEW view_name ASSELECT column1, column2…..FROM table_nameWHERE [condition]; 2.创建视图实例你可以只从一个表中取其中几列做为新视图，这里用两个表合并为一个视图。 mysql&gt; create view company_view as select e.id,e.name,e.age,d.dept from company e inner join department d where e.id=d.emp_id;Query OK, 0 rows affected (0.03 sec) mysql&gt; select * from company_view; 123456789101112+----+-------+------+-------------+| id | name | age | dept |+----+-------+------+-------------+| 1 | Paul | 32 | IT Billing || 2 | Allen | 25 | Engineering || 7 | James | 24 | Finance || 3 | Teddy | 23 | Engineering || 4 | Mark | 25 | Finance || 5 | David | 27 | Engineering || 6 | Kim | 22 | Finance |+----+-------+------+-------------+7 rows in set (0.00 sec) 3.删除视图 drop view view_name mysql&gt; show tables; 12345678910+--------------------+| Tables_in_learn_db |+--------------------+| company || company_view || department || employ || log |+--------------------+5 rows in set (0.01 sec) mysql&gt; drop view company_view;Query OK, 0 rows affected (0.00 sec) mysql&gt; show tables; 123456789+--------------------+| Tables_in_learn_db |+--------------------+| company || department || employ || log |+--------------------+4 rows in set (0.00 sec)","tags":[{"name":"sqlite","slug":"sqlite","permalink":"https://maxiaozhou1234.github.io/tags/sqlite/"}]},{"title":"【sqlite】Trigger 触发器","date":"2020-02-25T05:34:25.000Z","path":"sqlite/sqlite-trigger/","text":"sqlite Trigger 触发器 Trigger 触发器SQLite 触发器（Trigger）是数据库的回调函数，它会在指定的数据库事件发生时自动执行/调用。指定在特定的数据库表发生 DELETE、INSERT 或 UPDATE 时触发，或在一个或多个指定表的列发生更新时触发。 Trigger 详细资料链接 1.语法 CREATE TRIGGER trigger_name [BEFORE|AFTER] event_name[INSERT|UPDATE|DELETE] ON table_nameFOR EACH ROW（对 SQLite 可加可不加）BEGIN – 触发器逻辑….END; 2.SQLite 使用触发器1）创建记录表，用于存储触发后数据create table log(uid int,entry_date text); 2)创建触发器create TRIGGER emp_log AFTER INSERT ON employBEGININSERT INTO log(uid,rtime) values (new.id,datetime(‘now’,’localtime’));END; 3)向 employ 插入数据，查看log中记录 insert into employ values(5,’vv’,3000,100); 因为没有创建新表，所以存在之前的数据，旧数据再触发器之前存在是不会新增记录在 log 表中 1234567891011+------+------+--------+------------+| id | name | salary | manager_id |+------+------+--------+------------+| 1 | aa | 2000 | 3 || 2 | bb | 1000 | 3 || 3 | cc | 2500 | 4 || 4 | dd | 6000 | 100 || 100 | ee | 6000 | 0 || 5 | vv | 3000 | 100 |+------+------+--------+------------+6 rows in set (0.00 sec) log 中记录 select * from log; 123456+------+----------------------+| uid | entry_date |+------+----------------------+|5 | 2020-02-25 13: 07:02 |+------+----------------------+1 row in set (0.00 sec) 2.MySQL 使用触发器使用 MySQL 添加触发器语法和上面一致注意: 如果是在命令行中执行MySQL，需要将delimiter ; 更改为delimiter //，MySQL 默认使用分号 “;” 结束判断，不更改在遇到分号执行语句会导致提示语法错误导致创建触发器失败 需要增加 FOR EACH ROW， MySQL 不支持语句触发器,仅仅支持行级触发器，必须增加这句 示例如下： mysql&gt; delimiter //mysql&gt; CREATE TRIGGER emp_log AFTER INSERT ON employ -&gt; FOR EACH ROW -&gt; BEGIN -&gt; INSERT INTO log(uid) values (new.id); -&gt; END; -&gt; //Query OK, 0 rows affected (0.08 sec) 最后可以重新把分号执行修改回来，在命令行输入 mysql&gt; delimiter ; 3.MySQL 触发器查询，删除1)查询所有触发器 show triggers; 2)删除触发器 drop trigger xxx; (xxx 为触发器名称）","tags":[{"name":"sqlite","slug":"sqlite","permalink":"https://maxiaozhou1234.github.io/tags/sqlite/"}]},{"title":"【sqlite】unions 语法笔记","date":"2020-02-25T03:30:03.000Z","path":"sqlite/sqlite-union/","text":"SQLite unions 合并查询 SQLite的 UNION 子句/运算符用于合并两个或多个 SELECT 语句的结果，不返回任何重复的行。为了使用 UNION，每个 SELECT 被选择的列数必须是相同的，相同数目的列表达式，相同的数据类型，并确保它们有相同的顺序，但它们不必具有相同的长度。 SQLite unions 合并查询将表1和表2的内容合并输出，前提是两个表中的列必须一致(列名、顺序) 1.内联查询 mysql&gt; select emp_id,name,dept from company inner join department on company.id=department.emp_id; 123456789101112+--------+-------+-------------+| emp_id | name | dept |+--------+-------+-------------+| 1 | Paul | IT Billing || 2 | Allen | Engineering || 7 | James | Finance || 3 | Teddy | Engineering || 4 | Mark | Finance || 5 | David | Engineering || 6 | Kim | Finance |+--------+-------+-------------+7 rows in set (0.00 sec) 2.左外连接查询 mysql&gt; select emp_id,name,dept from company left outer join department on company.id=department.emp_id; 123456789101112+--------+-------+-------------+| emp_id | name | dept |+--------+-------+-------------+| 1 | Paul | IT Billing || 2 | Allen | Engineering || 3 | Teddy | Engineering || 4 | Mark | Finance || 5 | David | Engineering || 6 | Kim | Finance || 7 | James | Finance |+--------+-------+-------------+7 rows in set (0.00 sec) 3.联合输出 mysql&gt; select emp_id,name,dept from company inner join department on company.id=department.emp_id union select emp_id,name,dept from company left outer join department on company.id=department.emp_id; 123456789101112+--------+-------+-------------+| emp_id | name | dept |+--------+-------+-------------+| 1 | Paul | IT Billing || 2 | Allen | Engineering || 7 | James | Finance || 3 | Teddy | Engineering || 4 | Mark | Finance || 5 | David | Engineering || 6 | Kim | Finance |+--------+-------+-------------+7 rows in set (0.00 sec) 上面这个例子结果不能很好展现合并的效果，我们更改一下第二条查询的条件，增加员工id&lt;5，如下 mysql&gt;select emp_id,name,dept from company left outer join department on company.id=department.emp_id and company.id&lt;5; 123456789101112+--------+-------+-------------+| emp_id | name | dept |+--------+-------+-------------+| 1 | Paul | IT Billing || 2 | Allen | Engineering || 3 | Teddy | Engineering || 4 | Mark | Finance || NULL | David | NULL || NULL | Kim | NULL || NULL | James | NULL |+--------+-------+-------------+7 rows in set (0.00 sec) 这里我们看到左外连接后，id&gt;=5的员工数据被置为null，此时再联合输出： mysql&gt; select emp_id id,name,dept from company inner join department on company.id=department.emp_id union select emp_id,name,dept from company left outer join department on company.id=department.emp_id and company.id&lt;5; 123456789101112131415+------+-------+-------------+| id | name | dept |+------+-------+-------------+| 1 | Paul | IT Billing || 2 | Allen | Engineering || 7 | James | Finance || 3 | Teddy | Engineering || 4 | Mark | Finance || 5 | David | Engineering || 6 | Kim | Finance || NULL | David | NULL || NULL | Kim | NULL || NULL | James | NULL |+------+-------+-------------+10 rows in set (0.00 sec) 查询后可以看到，表1的查询结果都在，表2中1-4数据和表1相同合并为一，剩下三条再并表输出，总共数据为7+3 = 10条。 4.union all 合并所有仅使用 union 关键字，重复的项会被过滤，如果要保留两个表中的所有内容，可以使用union all合并所有数据。将上面的例子修改一下： mysql&gt; select emp_id id,name,dept from company inner join department on company.id=department.emp_id union all select emp_id,name,dept from company left outer join department on company.id=department.emp_id and company.id&lt;5; 12345678910111213141516171819+------+-------+-------------+| id | name | dept |+------+-------+-------------+| 1 | Paul | IT Billing || 2 | Allen | Engineering || 7 | James | Finance || 3 | Teddy | Engineering || 4 | Mark | Finance || 5 | David | Engineering || 6 | Kim | Finance || 1 | Paul | IT Billing || 2 | Allen | Engineering || 3 | Teddy | Engineering || 4 | Mark | Finance || NULL | David | NULL || NULL | Kim | NULL || NULL | James | NULL |+------+-------+-------------+14 rows in set (0.00 sec) 结果如上。","tags":[{"name":"sqlite","slug":"sqlite","permalink":"https://maxiaozhou1234.github.io/tags/sqlite/"}]},{"title":"【sqlite】join 语法笔记","date":"2020-02-25T02:01:00.000Z","path":"sqlite/sqlite-join/","text":"SQLite 数据库 join 语法笔记 SQLite 关键字 join1.cross join 交叉连接把第一个表的每一行和第二个表的每一行进行匹配。如表1有m行，表2有n行，交叉连接之后有 m*n 行。 select * from company; select * from department; select emp_id,name,dept from company cross join department; 2.inner join 内联根据连接条件结合两个表的列值创建一个新的结果表。内连接语法： SELECT … FROM table1 [INNER] JOIN table2 ON conditional_expression … 为了避免冗余，并保持较短的措辞，可以使用 USING 表达式声明内连接（INNER JOIN）条件。这个表达式指定一个或多个列的列表：注：如果两张表的关联字段名相同，才可以使用USING子句 SELECT … FROM table1 JOIN table2 USING ( column1 ,… ) … 自然连接（NATURAL JOIN）类似于 JOIN…USING，只是它会自动测试存在两个表中的每一列的值之间相等值： SELECT … FROM table1 NATURAL JOIN table2… 示例：select emp_id,name,dept from company inner join department on company.id=department.emp_id; 3.outer join 外连接外连接（OUTER JOIN）是内连接（INNER JOIN）的扩展。虽然 SQL 标准定义了三种类型的外连接：LEFT、RIGHT、FULL，但 SQLite 只支持 左外连接（LEFT OUTER JOIN）。 左连接 left outer join/left join关联两张或多张表中，根据条件显示匹配的数据。依附于左表进行扩展，扩展后表中内容如果右表没有匹配数据，则用 null 显示。 右连接 right outer join/right join关联两张或多张表中，根据条件显示匹配的数据。依附于右表进行扩展，扩展后表中内容如果左表没有匹配数据，则用 null 显示。 全连接 full outer join/right join全外连接就是关联的两张或多张表中，根据关联条件，显示所有匹配和不匹配的记录。左表中有的记录，但是右表中没有匹配上的，以空(null)显示。右表中有的记录，但是左表中没有匹配上的，也以空(null)显示。FULL OUTER JOIN也可以简写成FULL JOIN，效果是一样的。 左外连接语法： SELECT … FROM table1 LEFT OUTER JOIN table2 ON [conditional_expression 条件] … 为了避免冗余，可以使用 using 声明条件 SELECT … FROM table1 LEFT OUTER JOIN table2 USING ( column1 ,… ) … 示例：select emp_id,name,dept from company left outer join department on company.id=department.emp_id; 4.自连接，扩展只有一张表，通过把表取别名，当作两张表使用，自己和自己关联。 示例：查询经理的名称，通过员工id和经理id相同自连接查询 12345678910111213create table employ (id int,name char(20),salary real check(salary &gt;0),manager_id int);insert into employ values (1,&#39;aa&#39;,2000,3);insert into employ values (2,&#39;bb&#39;,1000,3);insert into employ values (3,&#39;cc&#39;,2500,4);insert into employ values (4,&#39;dd&#39;,6000,100);insert into employ values (100,&#39;ee&#39;,6000,0);默认使用 inner join，同样也可以使用left joinselect e.name,e.salary,e2.name manager from employ e ，employ e2 on e.manager_id &#x3D; e2.id;使用条件 whereselect e.name,e.salary,e2.name manager from employ e , employ e2 where e.manager_id &#x3D; e2.id; 图片存储记录：1.png2.png6.png4.png5.png3.png","tags":[{"name":"sqlite","slug":"sqlite","permalink":"https://maxiaozhou1234.github.io/tags/sqlite/"}]},{"title":"【MySQL】操作命令","date":"2020-02-25T02:00:00.000Z","path":"sqlite/mysql-cmd/","text":"MySQL 基本操作命令 MySQL 基本操作命令 查看所有数据库show databases; 使用数据库use xxx; 创建数据库create database xxx charset=utf8;//创建xx数据库，并指定编码 查看创建数据库时的语法命令show create database xxx; 查看数据库中所有的表show tables; 删除数据库drop database xxx; 查看所有触发器show triggers; 查看指定表触发器（使用 \\G 切换视图为纵向输出）select * from information_schema.triggers where EVENT_OBJECT_TABLE=’table_name’; 删除触发器drop trigger trigger_name; 查看表结构desc table;describe table; 创建视图create view view_name as select column1[…] from table where [condition]; 删除视图drop view name; MySQL 5.5版本注意 没有 datatime,如需要使用时间戳，用timestmap代替 默认使用分号；结束判断，如果需要多行输入，将delimiter ; 更改为delimiter //，按“//”为结束判断 没有 datetime ，时间戳使用 timestamp","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://maxiaozhou1234.github.io/tags/MySQL/"}]},{"title":"【java】NIO 小结","date":"2020-02-11T09:15:45.000Z","path":"java/java-nio/","text":"java NIO 学习后的小结 1. NIO 总述nio 为 Non-blocking io，即不阻塞io操作，java在为并发提供的 io 操作类，主要有三个核心类，分别为： Channel 操作数据通道 Buffer 缓冲数据区域 Selector 用于管理 channel 2. BIO 与 NIO 的主要区别2.1 面向操作BIO 是面向流操作，NIO 是面向缓冲操作。BIO 每次从流读写一个或多个字节，直至所有字节被读写完成，该过程数据没有被缓存到其它地方，它不能前后移动流中的数据。 NIO 将数据先缓冲到稍后处理的区域，需要时可以在缓冲区前后移动，具备处理过程中的灵活性。 2.2 阻塞与非阻塞Java IO 流失阻塞的，意味着，当线程调用 read（）或 write（）时，该线程被阻塞，直到数据完全读取或者写入，期间线程无法进行其它处理。 NIO 的非阻塞模式，可以让线程请求写入一些数据到某通道，但不需要等到操作完成，这个现场同时可以去做其他事情。线程通常将非阻塞IO空闲时间用于其他通道上执行IO操作，所以一个线程可以管理多个输入、输出通道。 2.3 选择器NIO 的选择器允许一个单独线程监视多个输入通道，可以注册多个通道使用一个选择器，然后监控可以处理的输入通道进行操作。 3. NIO 中的 channel3.1 FileChannelFileChannel 可以通过 RandomAccessFile.getChannel() 或 InputStream,OutputStream .getChannel() 获取，示例代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960private void channelCopy() &#123; Instant begin = Instant.now(); try &#123; RandomAccessFile source = new RandomAccessFile(\"./res/threeWithoutPunctuation\", \"r\"); RandomAccessFile target = new RandomAccessFile(\"./res/copyFileNio\", \"rw\"); ByteBuffer buffer = ByteBuffer.allocate(1024*8); FileChannel sourceChannel = source.getChannel(); FileChannel targetChannel = target.getChannel(); while (sourceChannel.read(buffer) != -1) &#123; buffer.flip(); while (buffer.hasRemaining()) &#123; targetChannel.write(buffer); &#125; buffer.clear(); &#125; sourceChannel.close(); targetChannel.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println(\"[channelCopy] Done &gt;&gt; \" + (Duration.between(begin, Instant.now()).toMillis()) + \" ms\");&#125;``` 测试在小文件复制速度可能不如流操作，但在大文件拷贝速度比流复制快，测试拷贝1.03G文件，channel 耗时 1.08s，而 stream 需要 11.31s。#### 3.2 DatagramChannelDatagramChannel 广播包的操作，区别不大，示例代码如下：服务端```javaprivate SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.getDefault());private void startServer() &#123; try &#123; DatagramChannel datagramChannel = DatagramChannel.open(); datagramChannel.configureBlocking(true); datagramChannel.socket().bind(new InetSocketAddress(8000)); System.out.println(\"启动服务端\"); ByteBuffer buffer = ByteBuffer.allocate(1024); SocketAddress socketAddress; while (true) &#123; //超过buffer大小部分将被丢弃 if ((socketAddress = datagramChannel.receive(buffer)) != null) &#123; buffer.flip(); System.out.println(Charset.forName(\"UTF-8\").decode(buffer)); buffer.clear(); datagramChannel.send(Charset.forName(\"UTF-8\").encode(\"服务端已收到[\" + format.format(new Date())), socketAddress); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 客户端 123456789101112131415161718192021222324252627282930313233343536373839public DatagramNioClient() &#123; try &#123; DatagramChannel datagramChannel = DatagramChannel.open(); datagramChannel.socket().bind(new InetSocketAddress(8001)); new Thread(() -&gt; &#123; try &#123; ByteBuffer buffer = ByteBuffer.allocate(1024); while (true) &#123; if (datagramChannel.receive(buffer) != null) &#123; buffer.flip(); System.out.print(\"收到消息：\"); System.out.println(Charset.forName(\"UTF-8\").decode(buffer)); buffer.clear(); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;).start(); System.out.println(\"启动客户端\"); Scanner scanner = new Scanner(System.in); while (scanner.hasNextLine()) &#123; send(datagramChannel, scanner.nextLine()); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;private void send(DatagramChannel datagramChannel, String msg) &#123; try &#123; datagramChannel.send(Charset.forName(\"UTF-8\").encode(msg), new InetSocketAddress(\"127.0.0.1\", 8000)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 需注意，如果接收数据超过设定容器的大小，超过部分会丢弃。比如对方发送了128K数据，而我容器只有48K大小，那么我只接收到48K数据，而剩余部分直接被丢弃。 对于数据的读取可以传入 ByteBuffer[] 数据，将按照顺序进行填充，对于一些固定大小数据头的数据包，使用非常方便，缺点容量一旦确定不可修改，弹性差，示例： 1234567891011private void start()&#123; try&#123; DatagramChannel datagramChannel = DatagramChannel.open(); datagramChannel.connect(new InetSocketAddress(\"127.0.0.1\",8001)); ByteBuffer headBuffer = ByteBuffer.allocate(48); ByteBuffer bodyBuffer = ByteBuffer.allocate(128); datagramChannel.read(new ByteBuffer[]&#123;headBuffer,bodyBuffer&#125;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 这里的 connect 并非真正的建立连接，而是锁定 channel 通道，让该通道只能通过特定的地址收发数据。 3.3 SocketChannel,ServerSocketChannel这两个 SocketChannel 是 socket 的并发版本，通常我们通过 ServerSocket 来监听端口，一旦有客户端连接，就创建线程进行通信，示例如下： 123456789101112131415private void server() throws IOException &#123; ServerSocket serverSocket = new ServerSocket(8000); Socket socket; while ((socket = serverSocket.accept()) != null) &#123; final Socket ss = socket; new Thread(() -&gt; &#123; try &#123; InputStream in = ss.getInputStream(); OutputStream out = ss.getOutputStream(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125;&#125; 每一次连接都需要创建线程进行通信，所以服务端线程数与客户端数量呈1:1关系，线程的创建需要消耗服务器资源，而服务器资源有限，在并发高且传输数据小的环境，这种方式无法满足要求。 SocketChannel 能够很好的解决高并发下的资源问题，通过 Selector 注册后，在非阻塞模式下仅使用单线程可以管理多个通道并实现数据传输，服务端示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445private void server() throws IOException &#123; //建立服务端监听，设置为非阻塞模式 ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); serverSocketChannel.configureBlocking(false); serverSocketChannel.bind(new InetSocketAddress(8000)); //将 channel 注册到 selector Selector selector = Selector.open(); serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); while (true) &#123; //检查是否有可处理通道 int num = selector.select(); if (num == 0) continue;//jdk 中空转有一定几率造成 cpu 100% Set&lt;SelectionKey&gt; set = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; it = set.iterator(); while (it.hasNext()) &#123; SelectionKey key = it.next(); it.remove(); if (key.isAcceptable()) &#123;//把通道注册为可读 ServerSocketChannel channel = (ServerSocketChannel) key.channel(); SocketChannel acceptChannel = channel.accept(); acceptChannel.configureBlocking(false); acceptChannel.register(selector,SelectionKey.OP_READ); &#125; else if (key.isReadable()) &#123;//处理已连接 channel 数据 SocketChannel channel = (SocketChannel) key.channel(); ByteBuffer buffer = ByteBuffer.allocate(1024); if(channel.read(buffer)!=-1)&#123; buffer.flip(); System.out.println(Charset.forName(\"UTF-8\").decode(buffer)); //do something channel.write(Charset.forName(\"UTF-8\").encode(\"回复\")); &#125; channel.close(); &#125; &#125; &#125;&#125; 从上面可以看出，SocketChannel 在并发量大处理的优越性。 如果是需要管理成千上万个连接，并且这些连接每次只是发送少量的数据，如聊天服务器这类需求，实现NIO服务器可能是一个优势，但如果是少量连接使用，一次发送大量数据，还是典型的IO服务器实现更符合要求。 当然 SocketChannel 还是存在缺点，比如注释中写到可能出现cpu占用100%的bug（说已修复但仍有小概率出现），api使用比较复杂，但对于小型的服务处理，NIO服务器仍然是一个高效可用的实现。","tags":[{"name":"java","slug":"java","permalink":"https://maxiaozhou1234.github.io/tags/java/"},{"name":"nio","slug":"nio","permalink":"https://maxiaozhou1234.github.io/tags/nio/"}]},{"title":"【其他】gittalk 配置问题","date":"2020-02-11T06:58:05.000Z","path":"default/gittalk/","text":"使用 gittalk 为 Hexo 添加评论功能，遇到问题及解决方法 1.申请及配置1.1 注册 gittalk可通过 Register a new OAuth application 进行注册。如果已经注册过，可以在 github 首页点击头像下拉，“Settings – Developer settings – OAuth Apps” 查看你的app，选择你注册的 app 进行再次编辑。 1.2 配置填写 Application name： 应用名称，随意 Homepage URL： 网站URL，对应自己博客地址 Application description ：描述，随意 Authorization callback URL：# 网站URL，博客地址就好 点击注册，页面会出现其中Client ID和Client Secret在后面的配置中需要用到 如我的 gittalk 填写如下： 1234Application name： CommentAppHomepage URL： https:&#x2F;&#x2F;maxiaozhou1234.github.io # 网站URL，对应自己博客地址Application description ：repo # 描述，随意Authorization callback URL：https:&#x2F;&#x2F;maxiaozhou1234.github.io # 网站URL，博客地址就好，如果有独立域名，可填写你的域名用于跳转 1.3 在主题的 _config.yml 进行配置123456789101112#Cmmentscomment: gitalk: enable: true ## 开启gitalk owner: ## GitHub的用户名 repo: ## 此评论存放的GitHub仓库 client_id: ## 复制刚才生成的clientID，例如. 75752dafe7907a897619 client_secret: ## 复制刚才生成的clientSecret，例如. ec2fb9054972c891289640354993b662f4cccc50 admin: ## Github的用户名 id: location.pathname language: zh-CN ## Language pagerDirection: last # Comment sorting direction, available values are last and first. 主题的配置，可以参考【Hexo博客折腾】BlueLake博客主题的详细配置 2. 搭建过程遇到的问题2.1 评论区显示 Error: Not Found遇到 Error: Not Found，这个问题是主题 _config.yml 中 gittalk 配置中 repo 填写错误，修改为你的博客主页即可，如我的博客配置如下： repo： maxiaozhou1234.github.io 2.2 博客评论登录跳转到首页问题申请配置是填写的Homepage URL,Authorization callback URL 不正确导致，第一个填博客首页，第二个是授权回调页面，因为我没有使用独立的域名，所以两个都填博客首页，如下 Homepage URL：https://maxiaozhou1234.github.ioAuthorization callback URL：https://maxiaozhou1234.github.io 如果你是有自己独立的域名，将 Authorization callback URL 填写为你的域名，前提是你已完成了域名的绑定，还有注意 https 和 http 区别，需完全一致。 参考文章：解决配置gitalk插件后初始化登录时跳转回首页","tags":[{"name":"gittalk","slug":"gittalk","permalink":"https://maxiaozhou1234.github.io/tags/gittalk/"},{"name":"hexo","slug":"hexo","permalink":"https://maxiaozhou1234.github.io/tags/hexo/"}]}]