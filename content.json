[{"title":"Hello World","date":"2020-02-11T15:37:40.386Z","path":"uncategorized/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"【java】NIO 小结","date":"2020-02-11T09:15:45.000Z","path":"uncategorized/java-nio/","text":"java NIO 学习后的小结 NIO 总述 nio 为 Non-blocking io，即不阻塞io操作，java在为并发提供的 io 操作类，主要有三个核心类，分别为： Channel 操作数据通道 Buffer 缓冲数据区域 Selector 用于管理 channel BIO 与 NIO 的主要区别 2.1 面向操作 BIO 是面向流操作，NIO 是面向缓冲操作。BIO 每次从流读写一个或多个字节，直至所有字节被读写完成，该过程数据没有被缓存到其它地方，它不能前后移动流中的数据。NIO 将数据先缓冲到稍后处理的区域，需要时可以在缓冲区前后移动，具备处理过程中的灵活性。 2.2 阻塞与非阻塞 Java IO 流失阻塞的，意味着，当线程调用 read（）或 write（）时，该线程被阻塞，直到数据完全读取或者写入，期间线程无法进行其它处理。NIO 的非阻塞模式，可以让线程请求写入一些数据到某通道，但不需要等到操作完成，这个现场同时可以去做其他事情。线程通常将非阻塞IO空闲时间用于其他通道上执行IO操作，所以一个线程可以管理多个输入、输出通道。 2.3 选择器 NIO 的选择器允许一个单独线程监视多个输入通道，可以注册多个通道使用一个选择器，然后监控可以处理的输入通道进行操作。 NIO 中的 channel 3.1 FileChannel FileChannel 可以通过 RandomAccessFile.getChannel() 或 InputStream,OutputStream .getChannel() 获取，示例代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private void channelCopy() &#123; Instant begin = Instant.now(); try &#123; RandomAccessFile source = new RandomAccessFile(\"./res/threeWithoutPunctuation\", \"r\"); RandomAccessFile target = new RandomAccessFile(\"./res/copyFileNio\", \"rw\"); ByteBuffer buffer = ByteBuffer.allocate(1024*8); FileChannel sourceChannel = source.getChannel(); FileChannel targetChannel = target.getChannel(); while (sourceChannel.read(buffer) != -1) &#123; buffer.flip(); while (buffer.hasRemaining()) &#123; targetChannel.write(buffer); &#125; buffer.clear(); &#125; sourceChannel.close(); targetChannel.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println(\"[channelCopy] Done &gt;&gt; \" + (Duration.between(begin, Instant.now()).toMillis()) + \" ms\"); &#125;``` 测试在小文件复制速度可能不如流操作，但在大文件拷贝速度比流复制快，测试拷贝1.03G文件，channel 耗时 1.08s，而 stream 需要 11.31s。3.2 DatagramChannelDatagramChannel 广播包的操作，区别不大，示例代码如下：服务端```java private SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.getDefault()); private void startServer() &#123; try &#123; DatagramChannel datagramChannel = DatagramChannel.open(); datagramChannel.configureBlocking(true); datagramChannel.socket().bind(new InetSocketAddress(8000)); System.out.println(\"启动服务端\"); ByteBuffer buffer = ByteBuffer.allocate(1024); SocketAddress socketAddress; while (true) &#123; //超过buffer大小部分将被丢弃 if ((socketAddress = datagramChannel.receive(buffer)) != null) &#123; buffer.flip(); System.out.println(Charset.forName(\"UTF-8\").decode(buffer)); buffer.clear(); datagramChannel.send(Charset.forName(\"UTF-8\").encode(\"服务端已收到[\" + format.format(new Date())), socketAddress); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 客户端 123456789101112131415161718192021222324252627282930313233343536373839public DatagramNioClient() &#123; try &#123; DatagramChannel datagramChannel = DatagramChannel.open(); datagramChannel.socket().bind(new InetSocketAddress(8001)); new Thread(() -&gt; &#123; try &#123; ByteBuffer buffer = ByteBuffer.allocate(1024); while (true) &#123; if (datagramChannel.receive(buffer) != null) &#123; buffer.flip(); System.out.print(\"收到消息：\"); System.out.println(Charset.forName(\"UTF-8\").decode(buffer)); buffer.clear(); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;).start(); System.out.println(\"启动客户端\"); Scanner scanner = new Scanner(System.in); while (scanner.hasNextLine()) &#123; send(datagramChannel, scanner.nextLine()); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;private void send(DatagramChannel datagramChannel, String msg) &#123; try &#123; datagramChannel.send(Charset.forName(\"UTF-8\").encode(msg), new InetSocketAddress(\"127.0.0.1\", 8000)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 需注意，如果接收数据超过设定容器的大小，超过部分会丢弃。对于数据的读取可以传入 ByteBuffer[] 数据，将按照顺序进行填充，对于一些固定大小数据头的数据包，使用非常方便，缺点容量一旦确定不可修改，弹性差 3.3 SocketChannel,ServerSocketChannel","tags":[{"name":"java","slug":"java","permalink":"https://maxiaozhou1234.github.io/tags/java/"},{"name":"nio","slug":"nio","permalink":"https://maxiaozhou1234.github.io/tags/nio/"}]},{"title":"gittalk 配置问题","date":"2020-02-11T06:58:05.000Z","path":"default/gittalk/","text":"使用 gittalk 为 Hexo 添加评论功能 注册 gittalk，可通过 Register a new OAuth application 进行注册。如果已经注册过，可以在 github 首页点击头像下拉，“Settings – Developer settings – OAuth Apps” 查看你的app，选择你注册的 app 进行再次编辑。 配置填写 Application name： 应用名称，随意 Homepage URL： 网站URL，对应自己博客地址 Application description ：描述，随意 Authorization callback URL：# 网站URL，博客地址就好 点击注册，页面会出现其中Client ID和Client Secret在后面的配置中需要用到 如我的 gittalk 填写如下： 1234Application name： CommentAppHomepage URL： https:&#x2F;&#x2F;maxiaozhou1234.github.io # 网站URL，对应自己博客地址Application description ：repo # 描述，随意Authorization callback URL：https:&#x2F;&#x2F;maxiaozhou1234.github.io # 网站URL，博客地址就好，如果有独立域名，可填写你的域名用于跳转 在主题的 _config.yml 进行配置 123456789101112#Cmmentscomment: gitalk: enable: true ## 开启gitalk owner: ## GitHub的用户名 repo: ## 此评论存放的GitHub仓库 client_id: ## 复制刚才生成的clientID，例如. 75752dafe7907a897619 client_secret: ## 复制刚才生成的clientSecret，例如. ec2fb9054972c891289640354993b662f4cccc50 admin: ## Github的用户名 id: location.pathname language: zh-CN ## Language pagerDirection: last # Comment sorting direction, available values are last and first. 主题的配置，可以参考【Hexo博客折腾】BlueLake博客主题的详细配置 搭建过程遇到的问题 评论区显示 Error: Not Found 遇到 Error: Not Found，这个问题是主题 _config.yml 中 gittalk 配置中 repo 填写错误，修改为你的博客主页即可，如我的博客配置如下： repo： maxiaozhou1234.github.io 博客评论登录跳转到首页问题 申请配置是填写的Homepage URL,Authorization callback URL 不正确导致，第一个填博客首页，第二个是授权回调页面，因为我没有使用独立的域名，所以两个都填博客首页，如下 Homepage URL：https://maxiaozhou1234.github.ioAuthorization callback URL：https://maxiaozhou1234.github.io 如果你是有自己独立的域名，将 Authorization callback URL 填写为你的域名，前提是你已完成了域名的绑定，还有注意 https 和 http 区别，需完全一致。 参考文章：解决配置gitalk插件后初始化登录时跳转回首页","tags":[{"name":"gittalk","slug":"gittalk","permalink":"https://maxiaozhou1234.github.io/tags/gittalk/"},{"name":"hexo","slug":"hexo","permalink":"https://maxiaozhou1234.github.io/tags/hexo/"}]}]