[{"title":"【java】NIO 小结","date":"2020-02-11T09:15:45.000Z","path":"java/java-nio/","text":"java NIO 学习后的小结 1. NIO 总述nio 为 Non-blocking io，即不阻塞io操作，java在为并发提供的 io 操作类，主要有三个核心类，分别为： Channel 操作数据通道 Buffer 缓冲数据区域 Selector 用于管理 channel 2. BIO 与 NIO 的主要区别2.1 面向操作BIO 是面向流操作，NIO 是面向缓冲操作。BIO 每次从流读写一个或多个字节，直至所有字节被读写完成，该过程数据没有被缓存到其它地方，它不能前后移动流中的数据。 NIO 将数据先缓冲到稍后处理的区域，需要时可以在缓冲区前后移动，具备处理过程中的灵活性。 2.2 阻塞与非阻塞Java IO 流失阻塞的，意味着，当线程调用 read（）或 write（）时，该线程被阻塞，直到数据完全读取或者写入，期间线程无法进行其它处理。 NIO 的非阻塞模式，可以让线程请求写入一些数据到某通道，但不需要等到操作完成，这个现场同时可以去做其他事情。线程通常将非阻塞IO空闲时间用于其他通道上执行IO操作，所以一个线程可以管理多个输入、输出通道。 2.3 选择器NIO 的选择器允许一个单独线程监视多个输入通道，可以注册多个通道使用一个选择器，然后监控可以处理的输入通道进行操作。 3. NIO 中的 channel3.1 FileChannelFileChannel 可以通过 RandomAccessFile.getChannel() 或 InputStream,OutputStream .getChannel() 获取，示例代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960private void channelCopy() &#123; Instant begin = Instant.now(); try &#123; RandomAccessFile source = new RandomAccessFile(\"./res/threeWithoutPunctuation\", \"r\"); RandomAccessFile target = new RandomAccessFile(\"./res/copyFileNio\", \"rw\"); ByteBuffer buffer = ByteBuffer.allocate(1024*8); FileChannel sourceChannel = source.getChannel(); FileChannel targetChannel = target.getChannel(); while (sourceChannel.read(buffer) != -1) &#123; buffer.flip(); while (buffer.hasRemaining()) &#123; targetChannel.write(buffer); &#125; buffer.clear(); &#125; sourceChannel.close(); targetChannel.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println(\"[channelCopy] Done &gt;&gt; \" + (Duration.between(begin, Instant.now()).toMillis()) + \" ms\");&#125;``` 测试在小文件复制速度可能不如流操作，但在大文件拷贝速度比流复制快，测试拷贝1.03G文件，channel 耗时 1.08s，而 stream 需要 11.31s。#### 3.2 DatagramChannelDatagramChannel 广播包的操作，区别不大，示例代码如下：服务端```javaprivate SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.getDefault());private void startServer() &#123; try &#123; DatagramChannel datagramChannel = DatagramChannel.open(); datagramChannel.configureBlocking(true); datagramChannel.socket().bind(new InetSocketAddress(8000)); System.out.println(\"启动服务端\"); ByteBuffer buffer = ByteBuffer.allocate(1024); SocketAddress socketAddress; while (true) &#123; //超过buffer大小部分将被丢弃 if ((socketAddress = datagramChannel.receive(buffer)) != null) &#123; buffer.flip(); System.out.println(Charset.forName(\"UTF-8\").decode(buffer)); buffer.clear(); datagramChannel.send(Charset.forName(\"UTF-8\").encode(\"服务端已收到[\" + format.format(new Date())), socketAddress); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 客户端 123456789101112131415161718192021222324252627282930313233343536373839public DatagramNioClient() &#123; try &#123; DatagramChannel datagramChannel = DatagramChannel.open(); datagramChannel.socket().bind(new InetSocketAddress(8001)); new Thread(() -&gt; &#123; try &#123; ByteBuffer buffer = ByteBuffer.allocate(1024); while (true) &#123; if (datagramChannel.receive(buffer) != null) &#123; buffer.flip(); System.out.print(\"收到消息：\"); System.out.println(Charset.forName(\"UTF-8\").decode(buffer)); buffer.clear(); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;).start(); System.out.println(\"启动客户端\"); Scanner scanner = new Scanner(System.in); while (scanner.hasNextLine()) &#123; send(datagramChannel, scanner.nextLine()); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;private void send(DatagramChannel datagramChannel, String msg) &#123; try &#123; datagramChannel.send(Charset.forName(\"UTF-8\").encode(msg), new InetSocketAddress(\"127.0.0.1\", 8000)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 需注意，如果接收数据超过设定容器的大小，超过部分会丢弃。比如对方发送了128K数据，而我容器只有48K大小，那么我只接收到48K数据，而剩余部分直接被丢弃。 对于数据的读取可以传入 ByteBuffer[] 数据，将按照顺序进行填充，对于一些固定大小数据头的数据包，使用非常方便，缺点容量一旦确定不可修改，弹性差，示例： 1234567891011private void start()&#123; try&#123; DatagramChannel datagramChannel = DatagramChannel.open(); datagramChannel.connect(new InetSocketAddress(\"127.0.0.1\",8001)); ByteBuffer headBuffer = ByteBuffer.allocate(48); ByteBuffer bodyBuffer = ByteBuffer.allocate(128); datagramChannel.read(new ByteBuffer[]&#123;headBuffer,bodyBuffer&#125;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 这里的 connect 并非真正的建立连接，而是锁定 channel 通道，让该通道只能通过特定的地址收发数据。 3.3 SocketChannel,ServerSocketChannel这两个 SocketChannel 是 socket 的并发版本，通常我们通过 ServerSocket 来监听端口，一旦有客户端连接，就创建线程进行通信，示例如下： 123456789101112131415private void server() throws IOException &#123; ServerSocket serverSocket = new ServerSocket(8000); Socket socket; while ((socket = serverSocket.accept()) != null) &#123; final Socket ss = socket; new Thread(() -&gt; &#123; try &#123; InputStream in = ss.getInputStream(); OutputStream out = ss.getOutputStream(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125;&#125; 每一次连接都需要创建线程进行通信，所以服务端线程数与客户端数量呈1:1关系，线程的创建需要消耗服务器资源，而服务器资源有限，在并发高且传输数据小的环境，这种方式无法满足要求。 SocketChannel 能够很好的解决高并发下的资源问题，通过 Selector 注册后，在非阻塞模式下仅使用单线程可以管理多个通道并实现数据传输，服务端示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243private void server() throws IOException &#123; //建立服务端监听，设置为非阻塞模式 ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); serverSocketChannel.configureBlocking(false); serverSocketChannel.bind(new InetSocketAddress(8000)); //将 channel 注册到 selector Selector selector = Selector.open(); serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); while (true) &#123; //检查是否有可处理通道 int num = selector.select(); if (num == 0) continue;//jdk 中空转有一定几率造成 cpu 100%，属于系统bug，需谨慎 Set&lt;SelectionKey&gt; set = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; it = set.iterator(); while (it.hasNext()) &#123; SelectionKey key = it.next(); it.remove(); if (key.isAcceptable()) &#123;//把通道注册为可读 ServerSocketChannel channel = (ServerSocketChannel) key.channel(); SocketChannel acceptChannel = channel.accept(); acceptChannel.configureBlocking(false); acceptChannel.register(selector,SelectionKey.OP_READ); &#125; else if (key.isReadable()) &#123;//处理已连接 channel 数据 SocketChannel channel = (SocketChannel) key.channel(); ByteBuffer buffer = ByteBuffer.allocate(1024); channel.read(buffer); System.out.println(Charset.forName(\"UTF-8\").decode(buffer)); //do something channel.write(Charset.forName(\"UTF-8\").encode(\"回复\")); channel.close(); &#125; &#125; &#125;&#125; 从上面可以看出，SocketChannel 在并发量大处理的优越性。 如果是需要管理成千上万个连接，并且这些连接每次只是发送少量的数据，如聊天服务器这类需求，实现NIO服务器可能是一个优势，但如果是少量连接使用，一次发送大量数据，还是典型的IO服务器实现更符合要求。 当然 SocketChannel 还是存在缺点，比如注释中写到可能出现cpu占用100%的bug（说已修复但仍有小概率出现），api使用比较复杂，但对于小型的服务处理，NIO服务器仍然是一个高效可用的实现。","tags":[{"name":"java","slug":"java","permalink":"https://maxiaozhou1234.github.io/tags/java/"},{"name":"nio","slug":"nio","permalink":"https://maxiaozhou1234.github.io/tags/nio/"}]},{"title":"【其他】gittalk 配置问题","date":"2020-02-11T06:58:05.000Z","path":"default/gittalk/","text":"使用 gittalk 为 Hexo 添加评论功能，遇到问题及解决方法 1.申请及配置1.1 注册 gittalk可通过 Register a new OAuth application 进行注册。如果已经注册过，可以在 github 首页点击头像下拉，“Settings – Developer settings – OAuth Apps” 查看你的app，选择你注册的 app 进行再次编辑。 1.2 配置填写 Application name： 应用名称，随意 Homepage URL： 网站URL，对应自己博客地址 Application description ：描述，随意 Authorization callback URL：# 网站URL，博客地址就好 点击注册，页面会出现其中Client ID和Client Secret在后面的配置中需要用到 如我的 gittalk 填写如下： 1234Application name： CommentAppHomepage URL： https:&#x2F;&#x2F;maxiaozhou1234.github.io # 网站URL，对应自己博客地址Application description ：repo # 描述，随意Authorization callback URL：https:&#x2F;&#x2F;maxiaozhou1234.github.io # 网站URL，博客地址就好，如果有独立域名，可填写你的域名用于跳转 1.3 在主题的 _config.yml 进行配置123456789101112#Cmmentscomment: gitalk: enable: true ## 开启gitalk owner: ## GitHub的用户名 repo: ## 此评论存放的GitHub仓库 client_id: ## 复制刚才生成的clientID，例如. 75752dafe7907a897619 client_secret: ## 复制刚才生成的clientSecret，例如. ec2fb9054972c891289640354993b662f4cccc50 admin: ## Github的用户名 id: location.pathname language: zh-CN ## Language pagerDirection: last # Comment sorting direction, available values are last and first. 主题的配置，可以参考【Hexo博客折腾】BlueLake博客主题的详细配置 2. 搭建过程遇到的问题2.1 评论区显示 Error: Not Found遇到 Error: Not Found，这个问题是主题 _config.yml 中 gittalk 配置中 repo 填写错误，修改为你的博客主页即可，如我的博客配置如下： repo： maxiaozhou1234.github.io 2.2 博客评论登录跳转到首页问题申请配置是填写的Homepage URL,Authorization callback URL 不正确导致，第一个填博客首页，第二个是授权回调页面，因为我没有使用独立的域名，所以两个都填博客首页，如下 Homepage URL：https://maxiaozhou1234.github.ioAuthorization callback URL：https://maxiaozhou1234.github.io 如果你是有自己独立的域名，将 Authorization callback URL 填写为你的域名，前提是你已完成了域名的绑定，还有注意 https 和 http 区别，需完全一致。 参考文章：解决配置gitalk插件后初始化登录时跳转回首页","tags":[{"name":"gittalk","slug":"gittalk","permalink":"https://maxiaozhou1234.github.io/tags/gittalk/"},{"name":"hexo","slug":"hexo","permalink":"https://maxiaozhou1234.github.io/tags/hexo/"}]}]